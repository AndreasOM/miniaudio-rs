/* automatically generated by rust-bindgen 0.55.1 */

# [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct __BindgenBitfieldUnit < Storage , Align > { storage : Storage , align : [Align ; 0] , } impl < Storage , Align > __BindgenBitfieldUnit < Storage , Align > { # [inline] pub const fn new (storage : Storage) -> Self { Self { storage , align : [] } } } impl < Storage , Align > __BindgenBitfieldUnit < Storage , Align > where Storage : AsRef < [u8] > + AsMut < [u8] >, { # [inline] pub fn get_bit (& self , index : usize) -> bool { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = self . storage . as_ref () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [inline] pub fn set_bit (& mut self , index : usize , val : bool) { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [inline] pub fn get (& self , bit_offset : usize , bit_width : u8) -> u64 { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; let mut val = 0 ; for i in 0 .. (bit_width as usize) { if self . get_bit (i + bit_offset) { let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [inline] pub fn set (& mut self , bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; for i in 0 .. (bit_width as usize) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; self . set_bit (index + bit_offset , val_bit_is_set) ; } } } pub const MA_VERSION_MAJOR : u32 = 0 ; pub const MA_VERSION_MINOR : u32 = 10 ; pub const MA_VERSION_REVISION : u32 = 20 ; pub const MA_TRUE : u32 = 1 ; pub const MA_FALSE : u32 = 0 ; pub const MA_SIZE_MAX : u32 = 4294967295 ; pub const MA_SIMD_ALIGNMENT : u32 = 64 ; pub const MA_LOG_LEVEL_VERBOSE : u32 = 4 ; pub const MA_LOG_LEVEL_INFO : u32 = 3 ; pub const MA_LOG_LEVEL_WARNING : u32 = 2 ; pub const MA_LOG_LEVEL_ERROR : u32 = 1 ; pub const MA_LOG_LEVEL : u32 = 1 ; pub const MA_CHANNEL_NONE : u32 = 0 ; pub const MA_CHANNEL_MONO : u32 = 1 ; pub const MA_CHANNEL_FRONT_LEFT : u32 = 2 ; pub const MA_CHANNEL_FRONT_RIGHT : u32 = 3 ; pub const MA_CHANNEL_FRONT_CENTER : u32 = 4 ; pub const MA_CHANNEL_LFE : u32 = 5 ; pub const MA_CHANNEL_BACK_LEFT : u32 = 6 ; pub const MA_CHANNEL_BACK_RIGHT : u32 = 7 ; pub const MA_CHANNEL_FRONT_LEFT_CENTER : u32 = 8 ; pub const MA_CHANNEL_FRONT_RIGHT_CENTER : u32 = 9 ; pub const MA_CHANNEL_BACK_CENTER : u32 = 10 ; pub const MA_CHANNEL_SIDE_LEFT : u32 = 11 ; pub const MA_CHANNEL_SIDE_RIGHT : u32 = 12 ; pub const MA_CHANNEL_TOP_CENTER : u32 = 13 ; pub const MA_CHANNEL_TOP_FRONT_LEFT : u32 = 14 ; pub const MA_CHANNEL_TOP_FRONT_CENTER : u32 = 15 ; pub const MA_CHANNEL_TOP_FRONT_RIGHT : u32 = 16 ; pub const MA_CHANNEL_TOP_BACK_LEFT : u32 = 17 ; pub const MA_CHANNEL_TOP_BACK_CENTER : u32 = 18 ; pub const MA_CHANNEL_TOP_BACK_RIGHT : u32 = 19 ; pub const MA_CHANNEL_AUX_0 : u32 = 20 ; pub const MA_CHANNEL_AUX_1 : u32 = 21 ; pub const MA_CHANNEL_AUX_2 : u32 = 22 ; pub const MA_CHANNEL_AUX_3 : u32 = 23 ; pub const MA_CHANNEL_AUX_4 : u32 = 24 ; pub const MA_CHANNEL_AUX_5 : u32 = 25 ; pub const MA_CHANNEL_AUX_6 : u32 = 26 ; pub const MA_CHANNEL_AUX_7 : u32 = 27 ; pub const MA_CHANNEL_AUX_8 : u32 = 28 ; pub const MA_CHANNEL_AUX_9 : u32 = 29 ; pub const MA_CHANNEL_AUX_10 : u32 = 30 ; pub const MA_CHANNEL_AUX_11 : u32 = 31 ; pub const MA_CHANNEL_AUX_12 : u32 = 32 ; pub const MA_CHANNEL_AUX_13 : u32 = 33 ; pub const MA_CHANNEL_AUX_14 : u32 = 34 ; pub const MA_CHANNEL_AUX_15 : u32 = 35 ; pub const MA_CHANNEL_AUX_16 : u32 = 36 ; pub const MA_CHANNEL_AUX_17 : u32 = 37 ; pub const MA_CHANNEL_AUX_18 : u32 = 38 ; pub const MA_CHANNEL_AUX_19 : u32 = 39 ; pub const MA_CHANNEL_AUX_20 : u32 = 40 ; pub const MA_CHANNEL_AUX_21 : u32 = 41 ; pub const MA_CHANNEL_AUX_22 : u32 = 42 ; pub const MA_CHANNEL_AUX_23 : u32 = 43 ; pub const MA_CHANNEL_AUX_24 : u32 = 44 ; pub const MA_CHANNEL_AUX_25 : u32 = 45 ; pub const MA_CHANNEL_AUX_26 : u32 = 46 ; pub const MA_CHANNEL_AUX_27 : u32 = 47 ; pub const MA_CHANNEL_AUX_28 : u32 = 48 ; pub const MA_CHANNEL_AUX_29 : u32 = 49 ; pub const MA_CHANNEL_AUX_30 : u32 = 50 ; pub const MA_CHANNEL_AUX_31 : u32 = 51 ; pub const MA_CHANNEL_LEFT : u32 = 2 ; pub const MA_CHANNEL_RIGHT : u32 = 3 ; pub const MA_CHANNEL_POSITION_COUNT : u32 = 52 ; pub const MA_SUCCESS : u32 = 0 ; pub const MA_ERROR : i32 = - 1 ; pub const MA_INVALID_ARGS : i32 = - 2 ; pub const MA_INVALID_OPERATION : i32 = - 3 ; pub const MA_OUT_OF_MEMORY : i32 = - 4 ; pub const MA_OUT_OF_RANGE : i32 = - 5 ; pub const MA_ACCESS_DENIED : i32 = - 6 ; pub const MA_DOES_NOT_EXIST : i32 = - 7 ; pub const MA_ALREADY_EXISTS : i32 = - 8 ; pub const MA_TOO_MANY_OPEN_FILES : i32 = - 9 ; pub const MA_INVALID_FILE : i32 = - 10 ; pub const MA_TOO_BIG : i32 = - 11 ; pub const MA_PATH_TOO_LONG : i32 = - 12 ; pub const MA_NAME_TOO_LONG : i32 = - 13 ; pub const MA_NOT_DIRECTORY : i32 = - 14 ; pub const MA_IS_DIRECTORY : i32 = - 15 ; pub const MA_DIRECTORY_NOT_EMPTY : i32 = - 16 ; pub const MA_END_OF_FILE : i32 = - 17 ; pub const MA_NO_SPACE : i32 = - 18 ; pub const MA_BUSY : i32 = - 19 ; pub const MA_IO_ERROR : i32 = - 20 ; pub const MA_INTERRUPT : i32 = - 21 ; pub const MA_UNAVAILABLE : i32 = - 22 ; pub const MA_ALREADY_IN_USE : i32 = - 23 ; pub const MA_BAD_ADDRESS : i32 = - 24 ; pub const MA_BAD_SEEK : i32 = - 25 ; pub const MA_BAD_PIPE : i32 = - 26 ; pub const MA_DEADLOCK : i32 = - 27 ; pub const MA_TOO_MANY_LINKS : i32 = - 28 ; pub const MA_NOT_IMPLEMENTED : i32 = - 29 ; pub const MA_NO_MESSAGE : i32 = - 30 ; pub const MA_BAD_MESSAGE : i32 = - 31 ; pub const MA_NO_DATA_AVAILABLE : i32 = - 32 ; pub const MA_INVALID_DATA : i32 = - 33 ; pub const MA_TIMEOUT : i32 = - 34 ; pub const MA_NO_NETWORK : i32 = - 35 ; pub const MA_NOT_UNIQUE : i32 = - 36 ; pub const MA_NOT_SOCKET : i32 = - 37 ; pub const MA_NO_ADDRESS : i32 = - 38 ; pub const MA_BAD_PROTOCOL : i32 = - 39 ; pub const MA_PROTOCOL_UNAVAILABLE : i32 = - 40 ; pub const MA_PROTOCOL_NOT_SUPPORTED : i32 = - 41 ; pub const MA_PROTOCOL_FAMILY_NOT_SUPPORTED : i32 = - 42 ; pub const MA_ADDRESS_FAMILY_NOT_SUPPORTED : i32 = - 43 ; pub const MA_SOCKET_NOT_SUPPORTED : i32 = - 44 ; pub const MA_CONNECTION_RESET : i32 = - 45 ; pub const MA_ALREADY_CONNECTED : i32 = - 46 ; pub const MA_NOT_CONNECTED : i32 = - 47 ; pub const MA_CONNECTION_REFUSED : i32 = - 48 ; pub const MA_NO_HOST : i32 = - 49 ; pub const MA_IN_PROGRESS : i32 = - 50 ; pub const MA_CANCELLED : i32 = - 51 ; pub const MA_MEMORY_ALREADY_MAPPED : i32 = - 52 ; pub const MA_AT_END : i32 = - 53 ; pub const MA_FORMAT_NOT_SUPPORTED : i32 = - 100 ; pub const MA_DEVICE_TYPE_NOT_SUPPORTED : i32 = - 101 ; pub const MA_SHARE_MODE_NOT_SUPPORTED : i32 = - 102 ; pub const MA_NO_BACKEND : i32 = - 103 ; pub const MA_NO_DEVICE : i32 = - 104 ; pub const MA_API_NOT_FOUND : i32 = - 105 ; pub const MA_INVALID_DEVICE_CONFIG : i32 = - 106 ; pub const MA_DEVICE_NOT_INITIALIZED : i32 = - 200 ; pub const MA_DEVICE_ALREADY_INITIALIZED : i32 = - 201 ; pub const MA_DEVICE_NOT_STARTED : i32 = - 202 ; pub const MA_DEVICE_NOT_STOPPED : i32 = - 203 ; pub const MA_FAILED_TO_INIT_BACKEND : i32 = - 300 ; pub const MA_FAILED_TO_OPEN_BACKEND_DEVICE : i32 = - 301 ; pub const MA_FAILED_TO_START_BACKEND_DEVICE : i32 = - 302 ; pub const MA_FAILED_TO_STOP_BACKEND_DEVICE : i32 = - 303 ; pub const MA_SAMPLE_RATE_8000 : u32 = 8000 ; pub const MA_SAMPLE_RATE_11025 : u32 = 11025 ; pub const MA_SAMPLE_RATE_16000 : u32 = 16000 ; pub const MA_SAMPLE_RATE_22050 : u32 = 22050 ; pub const MA_SAMPLE_RATE_24000 : u32 = 24000 ; pub const MA_SAMPLE_RATE_32000 : u32 = 32000 ; pub const MA_SAMPLE_RATE_44100 : u32 = 44100 ; pub const MA_SAMPLE_RATE_48000 : u32 = 48000 ; pub const MA_SAMPLE_RATE_88200 : u32 = 88200 ; pub const MA_SAMPLE_RATE_96000 : u32 = 96000 ; pub const MA_SAMPLE_RATE_176400 : u32 = 176400 ; pub const MA_SAMPLE_RATE_192000 : u32 = 192000 ; pub const MA_SAMPLE_RATE_352800 : u32 = 352800 ; pub const MA_SAMPLE_RATE_384000 : u32 = 384000 ; pub const MA_MIN_CHANNELS : u32 = 1 ; pub const MA_MAX_CHANNELS : u32 = 32 ; pub const MA_MIN_SAMPLE_RATE : u32 = 8000 ; pub const MA_MAX_SAMPLE_RATE : u32 = 384000 ; pub const MA_MAX_FILTER_ORDER : u32 = 8 ; pub const MA_OPEN_MODE_READ : u32 = 1 ; pub const MA_OPEN_MODE_WRITE : u32 = 2 ; pub type __darwin_size_t = libc :: c_ulong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __darwin_pthread_handler_rec { pub __routine : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut libc :: c_void) > , pub __arg : * mut libc :: c_void , pub __next : * mut __darwin_pthread_handler_rec , } # [repr (C)] # [derive (Copy , Clone)] pub struct _opaque_pthread_cond_t { pub __sig : libc :: c_long , pub __opaque : [libc :: c_char ; 40usize] , } impl :: core :: fmt :: Debug for _opaque_pthread_cond_t { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "_opaque_pthread_cond_t {{ __sig: {:?}, __opaque: [...] }}" , self . __sig) } } # [repr (C)] # [derive (Copy , Clone)] pub struct _opaque_pthread_mutex_t { pub __sig : libc :: c_long , pub __opaque : [libc :: c_char ; 56usize] , } impl :: core :: fmt :: Debug for _opaque_pthread_mutex_t { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "_opaque_pthread_mutex_t {{ __sig: {:?}, __opaque: [...] }}" , self . __sig) } } # [repr (C)] # [derive (Copy , Clone)] pub struct _opaque_pthread_t { pub __sig : libc :: c_long , pub __cleanup_stack : * mut __darwin_pthread_handler_rec , pub __opaque : [libc :: c_char ; 8176usize] , } impl :: core :: fmt :: Debug for _opaque_pthread_t { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "_opaque_pthread_t {{ __sig: {:?}, __cleanup_stack: {:?}, __opaque: [...] }}" , self . __sig , self . __cleanup_stack) } } pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t ; pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t ; pub type __darwin_pthread_t = * mut _opaque_pthread_t ; pub type pthread_cond_t = __darwin_pthread_cond_t ; pub type pthread_mutex_t = __darwin_pthread_mutex_t ; pub type pthread_t = __darwin_pthread_t ; pub type wchar_t = libc :: c_int ; pub type ma_int8 = libc :: c_schar ; pub type ma_uint8 = libc :: c_uchar ; pub type ma_int16 = libc :: c_short ; pub type ma_uint16 = libc :: c_ushort ; pub type ma_int32 = libc :: c_int ; pub type ma_uint32 = libc :: c_uint ; pub type ma_int64 = libc :: c_longlong ; pub type ma_uint64 = libc :: c_ulonglong ; pub type ma_uintptr = ma_uint64 ; pub type ma_bool8 = ma_uint8 ; pub type ma_bool32 = ma_uint32 ; pub type ma_handle = * mut libc :: c_void ; pub type ma_ptr = * mut libc :: c_void ; pub type ma_proc = :: core :: option :: Option < unsafe extern "C" fn () > ; pub type ma_channel = ma_uint8 ; pub type ma_result = libc :: c_int ; pub const ma_stream_format_pcm : ma_stream_format = 0 ; pub type ma_stream_format = libc :: c_uint ; pub const ma_stream_layout_interleaved : ma_stream_layout = 0 ; pub const ma_stream_layout_deinterleaved : ma_stream_layout = 1 ; pub type ma_stream_layout = libc :: c_uint ; pub const ma_dither_mode_none : ma_dither_mode = 0 ; pub const ma_dither_mode_rectangle : ma_dither_mode = 1 ; pub const ma_dither_mode_triangle : ma_dither_mode = 2 ; pub type ma_dither_mode = libc :: c_uint ; pub const ma_format_unknown : ma_format = 0 ; pub const ma_format_u8 : ma_format = 1 ; pub const ma_format_s16 : ma_format = 2 ; pub const ma_format_s24 : ma_format = 3 ; pub const ma_format_s32 : ma_format = 4 ; pub const ma_format_f32 : ma_format = 5 ; pub const ma_format_count : ma_format = 6 ; pub type ma_format = libc :: c_uint ; pub const ma_channel_mix_mode_rectangular : ma_channel_mix_mode = 0 ; pub const ma_channel_mix_mode_simple : ma_channel_mix_mode = 1 ; pub const ma_channel_mix_mode_custom_weights : ma_channel_mix_mode = 2 ; pub const ma_channel_mix_mode_planar_blend : ma_channel_mix_mode = 0 ; pub const ma_channel_mix_mode_default : ma_channel_mix_mode = 0 ; pub type ma_channel_mix_mode = libc :: c_uint ; pub const ma_standard_channel_map_microsoft : ma_standard_channel_map = 0 ; pub const ma_standard_channel_map_alsa : ma_standard_channel_map = 1 ; pub const ma_standard_channel_map_rfc3551 : ma_standard_channel_map = 2 ; pub const ma_standard_channel_map_flac : ma_standard_channel_map = 3 ; pub const ma_standard_channel_map_vorbis : ma_standard_channel_map = 4 ; pub const ma_standard_channel_map_sound4 : ma_standard_channel_map = 5 ; pub const ma_standard_channel_map_sndio : ma_standard_channel_map = 6 ; pub const ma_standard_channel_map_webaudio : ma_standard_channel_map = 3 ; pub const ma_standard_channel_map_default : ma_standard_channel_map = 0 ; pub type ma_standard_channel_map = libc :: c_uint ; pub const ma_performance_profile_low_latency : ma_performance_profile = 0 ; pub const ma_performance_profile_conservative : ma_performance_profile = 1 ; pub type ma_performance_profile = libc :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_allocation_callbacks { pub pUserData : * mut libc :: c_void , pub onMalloc : :: core :: option :: Option < unsafe extern "C" fn (sz : usize , pUserData : * mut libc :: c_void) -> * mut libc :: c_void > , pub onRealloc : :: core :: option :: Option < unsafe extern "C" fn (p : * mut libc :: c_void , sz : usize , pUserData : * mut libc :: c_void) -> * mut libc :: c_void > , pub onFree : :: core :: option :: Option < unsafe extern "C" fn (p : * mut libc :: c_void , pUserData : * mut libc :: c_void) > , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_lcg { pub state : ma_int32 , } pub const ma_thread_priority_idle : ma_thread_priority = - 5 ; pub const ma_thread_priority_lowest : ma_thread_priority = - 4 ; pub const ma_thread_priority_low : ma_thread_priority = - 3 ; pub const ma_thread_priority_normal : ma_thread_priority = - 2 ; pub const ma_thread_priority_high : ma_thread_priority = - 1 ; pub const ma_thread_priority_highest : ma_thread_priority = 0 ; pub const ma_thread_priority_realtime : ma_thread_priority = 1 ; pub const ma_thread_priority_default : ma_thread_priority = 0 ; pub type ma_thread_priority = libc :: c_int ; pub type ma_spinlock = libc :: c_uchar ; pub type ma_thread = pthread_t ; pub type ma_mutex = pthread_mutex_t ; # [repr (C)] # [derive (Copy , Clone)] pub struct ma_event { pub value : ma_uint32 , pub lock : pthread_mutex_t , pub cond : pthread_cond_t , } impl :: core :: fmt :: Debug for ma_event { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_event {{ value: {:?}, lock: {:?}, cond: {:?} }}" , self . value , self . lock , self . cond) } } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_semaphore { pub value : libc :: c_int , pub lock : pthread_mutex_t , pub cond : pthread_cond_t , } impl :: core :: fmt :: Debug for ma_semaphore { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_semaphore {{ value: {:?}, lock: {:?}, cond: {:?} }}" , self . value , self . lock , self . cond) } } extern "C" { pub fn ma_version (pMajor : * mut ma_uint32 , pMinor : * mut ma_uint32 , pRevision : * mut ma_uint32) ; } extern "C" { pub fn ma_version_string () -> * const libc :: c_char ; } # [doc = "Biquad Filtering"] # [repr (C)] # [derive (Copy , Clone)] pub union ma_biquad_coefficient { pub f32_ : f32 , pub s32 : ma_int32 , _bindgen_union_align : u32 , } impl :: core :: fmt :: Debug for ma_biquad_coefficient { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_biquad_coefficient {{ union }}") } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_biquad_config { pub format : ma_format , pub channels : ma_uint32 , pub b0 : f64 , pub b1 : f64 , pub b2 : f64 , pub a0 : f64 , pub a1 : f64 , pub a2 : f64 , } extern "C" { pub fn ma_biquad_config_init (format : ma_format , channels : ma_uint32 , b0 : f64 , b1 : f64 , b2 : f64 , a0 : f64 , a1 : f64 , a2 : f64) -> ma_biquad_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_biquad { pub format : ma_format , pub channels : ma_uint32 , pub b0 : ma_biquad_coefficient , pub b1 : ma_biquad_coefficient , pub b2 : ma_biquad_coefficient , pub a1 : ma_biquad_coefficient , pub a2 : ma_biquad_coefficient , pub r1 : [ma_biquad_coefficient ; 32usize] , pub r2 : [ma_biquad_coefficient ; 32usize] , } impl :: core :: fmt :: Debug for ma_biquad { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_biquad {{ format: {:?}, channels: {:?}, b0: {:?}, b1: {:?}, b2: {:?}, a1: {:?}, a2: {:?}, r1: [...], r2: [...] }}" , self . format , self . channels , self . b0 , self . b1 , self . b2 , self . a1 , self . a2) } } extern "C" { pub fn ma_biquad_init (pConfig : * const ma_biquad_config , pBQ : * mut ma_biquad) -> ma_result ; } extern "C" { pub fn ma_biquad_reinit (pConfig : * const ma_biquad_config , pBQ : * mut ma_biquad) -> ma_result ; } extern "C" { pub fn ma_biquad_process_pcm_frames (pBQ : * mut ma_biquad , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_biquad_get_latency (pBQ : * mut ma_biquad) -> ma_uint32 ; } # [doc = "Low-Pass Filtering"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_lpf1_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub cutoffFrequency : f64 , pub q : f64 , } # [doc = "Low-Pass Filtering"] pub type ma_lpf2_config = ma_lpf1_config ; extern "C" { pub fn ma_lpf1_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64) -> ma_lpf1_config ; } extern "C" { pub fn ma_lpf2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64 , q : f64) -> ma_lpf2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_lpf1 { pub format : ma_format , pub channels : ma_uint32 , pub a : ma_biquad_coefficient , pub r1 : [ma_biquad_coefficient ; 32usize] , } impl :: core :: fmt :: Debug for ma_lpf1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_lpf1 {{ format: {:?}, channels: {:?}, a: {:?}, r1: [...] }}" , self . format , self . channels , self . a) } } extern "C" { pub fn ma_lpf1_init (pConfig : * const ma_lpf1_config , pLPF : * mut ma_lpf1) -> ma_result ; } extern "C" { pub fn ma_lpf1_reinit (pConfig : * const ma_lpf1_config , pLPF : * mut ma_lpf1) -> ma_result ; } extern "C" { pub fn ma_lpf1_process_pcm_frames (pLPF : * mut ma_lpf1 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_lpf1_get_latency (pLPF : * mut ma_lpf1) -> ma_uint32 ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_lpf2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_lpf2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_lpf2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_lpf2_init (pConfig : * const ma_lpf2_config , pLPF : * mut ma_lpf2) -> ma_result ; } extern "C" { pub fn ma_lpf2_reinit (pConfig : * const ma_lpf2_config , pLPF : * mut ma_lpf2) -> ma_result ; } extern "C" { pub fn ma_lpf2_process_pcm_frames (pLPF : * mut ma_lpf2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_lpf2_get_latency (pLPF : * mut ma_lpf2) -> ma_uint32 ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_lpf_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub cutoffFrequency : f64 , pub order : ma_uint32 , } extern "C" { pub fn ma_lpf_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64 , order : ma_uint32) -> ma_lpf_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_lpf { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub lpf1Count : ma_uint32 , pub lpf2Count : ma_uint32 , pub lpf1 : [ma_lpf1 ; 1usize] , pub lpf2 : [ma_lpf2 ; 4usize] , } impl :: core :: fmt :: Debug for ma_lpf { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_lpf {{ format: {:?}, channels: {:?}, sampleRate: {:?}, lpf1Count: {:?}, lpf2Count: {:?}, lpf1: {:?}, lpf2: {:?} }}" , self . format , self . channels , self . sampleRate , self . lpf1Count , self . lpf2Count , self . lpf1 , self . lpf2) } } extern "C" { pub fn ma_lpf_init (pConfig : * const ma_lpf_config , pLPF : * mut ma_lpf) -> ma_result ; } extern "C" { pub fn ma_lpf_reinit (pConfig : * const ma_lpf_config , pLPF : * mut ma_lpf) -> ma_result ; } extern "C" { pub fn ma_lpf_process_pcm_frames (pLPF : * mut ma_lpf , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_lpf_get_latency (pLPF : * mut ma_lpf) -> ma_uint32 ; } # [doc = "High-Pass Filtering"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_hpf1_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub cutoffFrequency : f64 , pub q : f64 , } # [doc = "High-Pass Filtering"] pub type ma_hpf2_config = ma_hpf1_config ; extern "C" { pub fn ma_hpf1_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64) -> ma_hpf1_config ; } extern "C" { pub fn ma_hpf2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64 , q : f64) -> ma_hpf2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_hpf1 { pub format : ma_format , pub channels : ma_uint32 , pub a : ma_biquad_coefficient , pub r1 : [ma_biquad_coefficient ; 32usize] , } impl :: core :: fmt :: Debug for ma_hpf1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_hpf1 {{ format: {:?}, channels: {:?}, a: {:?}, r1: [...] }}" , self . format , self . channels , self . a) } } extern "C" { pub fn ma_hpf1_init (pConfig : * const ma_hpf1_config , pHPF : * mut ma_hpf1) -> ma_result ; } extern "C" { pub fn ma_hpf1_reinit (pConfig : * const ma_hpf1_config , pHPF : * mut ma_hpf1) -> ma_result ; } extern "C" { pub fn ma_hpf1_process_pcm_frames (pHPF : * mut ma_hpf1 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_hpf1_get_latency (pHPF : * mut ma_hpf1) -> ma_uint32 ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_hpf2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_hpf2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_hpf2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_hpf2_init (pConfig : * const ma_hpf2_config , pHPF : * mut ma_hpf2) -> ma_result ; } extern "C" { pub fn ma_hpf2_reinit (pConfig : * const ma_hpf2_config , pHPF : * mut ma_hpf2) -> ma_result ; } extern "C" { pub fn ma_hpf2_process_pcm_frames (pHPF : * mut ma_hpf2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_hpf2_get_latency (pHPF : * mut ma_hpf2) -> ma_uint32 ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_hpf_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub cutoffFrequency : f64 , pub order : ma_uint32 , } extern "C" { pub fn ma_hpf_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64 , order : ma_uint32) -> ma_hpf_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_hpf { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub hpf1Count : ma_uint32 , pub hpf2Count : ma_uint32 , pub hpf1 : [ma_hpf1 ; 1usize] , pub hpf2 : [ma_hpf2 ; 4usize] , } impl :: core :: fmt :: Debug for ma_hpf { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_hpf {{ format: {:?}, channels: {:?}, sampleRate: {:?}, hpf1Count: {:?}, hpf2Count: {:?}, hpf1: {:?}, hpf2: {:?} }}" , self . format , self . channels , self . sampleRate , self . hpf1Count , self . hpf2Count , self . hpf1 , self . hpf2) } } extern "C" { pub fn ma_hpf_init (pConfig : * const ma_hpf_config , pHPF : * mut ma_hpf) -> ma_result ; } extern "C" { pub fn ma_hpf_reinit (pConfig : * const ma_hpf_config , pHPF : * mut ma_hpf) -> ma_result ; } extern "C" { pub fn ma_hpf_process_pcm_frames (pHPF : * mut ma_hpf , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_hpf_get_latency (pHPF : * mut ma_hpf) -> ma_uint32 ; } # [doc = "Band-Pass Filtering"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_bpf2_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub cutoffFrequency : f64 , pub q : f64 , } extern "C" { pub fn ma_bpf2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64 , q : f64) -> ma_bpf2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_bpf2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_bpf2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_bpf2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_bpf2_init (pConfig : * const ma_bpf2_config , pBPF : * mut ma_bpf2) -> ma_result ; } extern "C" { pub fn ma_bpf2_reinit (pConfig : * const ma_bpf2_config , pBPF : * mut ma_bpf2) -> ma_result ; } extern "C" { pub fn ma_bpf2_process_pcm_frames (pBPF : * mut ma_bpf2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_bpf2_get_latency (pBPF : * mut ma_bpf2) -> ma_uint32 ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_bpf_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub cutoffFrequency : f64 , pub order : ma_uint32 , } extern "C" { pub fn ma_bpf_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , cutoffFrequency : f64 , order : ma_uint32) -> ma_bpf_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_bpf { pub format : ma_format , pub channels : ma_uint32 , pub bpf2Count : ma_uint32 , pub bpf2 : [ma_bpf2 ; 4usize] , } impl :: core :: fmt :: Debug for ma_bpf { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_bpf {{ format: {:?}, channels: {:?}, bpf2Count: {:?}, bpf2: {:?} }}" , self . format , self . channels , self . bpf2Count , self . bpf2) } } extern "C" { pub fn ma_bpf_init (pConfig : * const ma_bpf_config , pBPF : * mut ma_bpf) -> ma_result ; } extern "C" { pub fn ma_bpf_reinit (pConfig : * const ma_bpf_config , pBPF : * mut ma_bpf) -> ma_result ; } extern "C" { pub fn ma_bpf_process_pcm_frames (pBPF : * mut ma_bpf , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_bpf_get_latency (pBPF : * mut ma_bpf) -> ma_uint32 ; } # [doc = "Notching Filter"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_notch2_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub q : f64 , pub frequency : f64 , } extern "C" { pub fn ma_notch2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , q : f64 , frequency : f64) -> ma_notch2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_notch2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_notch2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_notch2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_notch2_init (pConfig : * const ma_notch2_config , pFilter : * mut ma_notch2) -> ma_result ; } extern "C" { pub fn ma_notch2_reinit (pConfig : * const ma_notch2_config , pFilter : * mut ma_notch2) -> ma_result ; } extern "C" { pub fn ma_notch2_process_pcm_frames (pFilter : * mut ma_notch2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_notch2_get_latency (pFilter : * mut ma_notch2) -> ma_uint32 ; } # [doc = "Peaking EQ Filter"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_peak2_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub gainDB : f64 , pub q : f64 , pub frequency : f64 , } extern "C" { pub fn ma_peak2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , gainDB : f64 , q : f64 , frequency : f64) -> ma_peak2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_peak2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_peak2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_peak2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_peak2_init (pConfig : * const ma_peak2_config , pFilter : * mut ma_peak2) -> ma_result ; } extern "C" { pub fn ma_peak2_reinit (pConfig : * const ma_peak2_config , pFilter : * mut ma_peak2) -> ma_result ; } extern "C" { pub fn ma_peak2_process_pcm_frames (pFilter : * mut ma_peak2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_peak2_get_latency (pFilter : * mut ma_peak2) -> ma_uint32 ; } # [doc = "Low Shelf Filter"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_loshelf2_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub gainDB : f64 , pub shelfSlope : f64 , pub frequency : f64 , } extern "C" { pub fn ma_loshelf2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , gainDB : f64 , shelfSlope : f64 , frequency : f64) -> ma_loshelf2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_loshelf2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_loshelf2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_loshelf2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_loshelf2_init (pConfig : * const ma_loshelf2_config , pFilter : * mut ma_loshelf2) -> ma_result ; } extern "C" { pub fn ma_loshelf2_reinit (pConfig : * const ma_loshelf2_config , pFilter : * mut ma_loshelf2) -> ma_result ; } extern "C" { pub fn ma_loshelf2_process_pcm_frames (pFilter : * mut ma_loshelf2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_loshelf2_get_latency (pFilter : * mut ma_loshelf2) -> ma_uint32 ; } # [doc = "High Shelf Filter"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_hishelf2_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub gainDB : f64 , pub shelfSlope : f64 , pub frequency : f64 , } extern "C" { pub fn ma_hishelf2_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , gainDB : f64 , shelfSlope : f64 , frequency : f64) -> ma_hishelf2_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_hishelf2 { pub bq : ma_biquad , } impl :: core :: fmt :: Debug for ma_hishelf2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_hishelf2 {{ bq: {:?} }}" , self . bq) } } extern "C" { pub fn ma_hishelf2_init (pConfig : * const ma_hishelf2_config , pFilter : * mut ma_hishelf2) -> ma_result ; } extern "C" { pub fn ma_hishelf2_reinit (pConfig : * const ma_hishelf2_config , pFilter : * mut ma_hishelf2) -> ma_result ; } extern "C" { pub fn ma_hishelf2_process_pcm_frames (pFilter : * mut ma_hishelf2 , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_hishelf2_get_latency (pFilter : * mut ma_hishelf2) -> ma_uint32 ; } # [doc = "Resampling"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_linear_resampler_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRateIn : ma_uint32 , pub sampleRateOut : ma_uint32 , pub lpfOrder : ma_uint32 , pub lpfNyquistFactor : f64 , } extern "C" { pub fn ma_linear_resampler_config_init (format : ma_format , channels : ma_uint32 , sampleRateIn : ma_uint32 , sampleRateOut : ma_uint32) -> ma_linear_resampler_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_linear_resampler { pub config : ma_linear_resampler_config , pub inAdvanceInt : ma_uint32 , pub inAdvanceFrac : ma_uint32 , pub inTimeInt : ma_uint32 , pub inTimeFrac : ma_uint32 , pub x0 : ma_linear_resampler__bindgen_ty_1 , pub x1 : ma_linear_resampler__bindgen_ty_2 , pub lpf : ma_lpf , } # [repr (C)] # [derive (Copy , Clone)] pub union ma_linear_resampler__bindgen_ty_1 { pub f32_ : [f32 ; 32usize] , pub s16 : [ma_int16 ; 32usize] , _bindgen_union_align : [u32 ; 32usize] , } impl :: core :: fmt :: Debug for ma_linear_resampler__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_linear_resampler__bindgen_ty_1 {{ union }}") } } # [repr (C)] # [derive (Copy , Clone)] pub union ma_linear_resampler__bindgen_ty_2 { pub f32_ : [f32 ; 32usize] , pub s16 : [ma_int16 ; 32usize] , _bindgen_union_align : [u32 ; 32usize] , } impl :: core :: fmt :: Debug for ma_linear_resampler__bindgen_ty_2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_linear_resampler__bindgen_ty_2 {{ union }}") } } impl :: core :: fmt :: Debug for ma_linear_resampler { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_linear_resampler {{ config: {:?}, inAdvanceInt: {:?}, inAdvanceFrac: {:?}, inTimeInt: {:?}, inTimeFrac: {:?}, x0: {:?}, x1: {:?}, lpf: {:?} }}" , self . config , self . inAdvanceInt , self . inAdvanceFrac , self . inTimeInt , self . inTimeFrac , self . x0 , self . x1 , self . lpf) } } extern "C" { pub fn ma_linear_resampler_init (pConfig : * const ma_linear_resampler_config , pResampler : * mut ma_linear_resampler) -> ma_result ; } extern "C" { pub fn ma_linear_resampler_uninit (pResampler : * mut ma_linear_resampler) ; } extern "C" { pub fn ma_linear_resampler_process_pcm_frames (pResampler : * mut ma_linear_resampler , pFramesIn : * const libc :: c_void , pFrameCountIn : * mut ma_uint64 , pFramesOut : * mut libc :: c_void , pFrameCountOut : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_linear_resampler_set_rate (pResampler : * mut ma_linear_resampler , sampleRateIn : ma_uint32 , sampleRateOut : ma_uint32) -> ma_result ; } extern "C" { pub fn ma_linear_resampler_set_rate_ratio (pResampler : * mut ma_linear_resampler , ratioInOut : f32) -> ma_result ; } extern "C" { pub fn ma_linear_resampler_get_required_input_frame_count (pResampler : * mut ma_linear_resampler , outputFrameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_linear_resampler_get_expected_output_frame_count (pResampler : * mut ma_linear_resampler , inputFrameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_linear_resampler_get_input_latency (pResampler : * mut ma_linear_resampler) -> ma_uint64 ; } extern "C" { pub fn ma_linear_resampler_get_output_latency (pResampler : * mut ma_linear_resampler) -> ma_uint64 ; } pub const ma_resample_algorithm_linear : ma_resample_algorithm = 0 ; pub const ma_resample_algorithm_speex : ma_resample_algorithm = 1 ; pub type ma_resample_algorithm = libc :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_resampler_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRateIn : ma_uint32 , pub sampleRateOut : ma_uint32 , pub algorithm : ma_resample_algorithm , pub linear : ma_resampler_config__bindgen_ty_1 , pub speex : ma_resampler_config__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_resampler_config__bindgen_ty_1 { pub lpfOrder : ma_uint32 , pub lpfNyquistFactor : f64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_resampler_config__bindgen_ty_2 { pub quality : libc :: c_int , } extern "C" { pub fn ma_resampler_config_init (format : ma_format , channels : ma_uint32 , sampleRateIn : ma_uint32 , sampleRateOut : ma_uint32 , algorithm : ma_resample_algorithm) -> ma_resampler_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_resampler { pub config : ma_resampler_config , pub state : ma_resampler__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union ma_resampler__bindgen_ty_1 { pub linear : ma_linear_resampler , pub speex : ma_resampler__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [u64 ; 200usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_resampler__bindgen_ty_1__bindgen_ty_1 { pub pSpeexResamplerState : * mut libc :: c_void , } impl :: core :: fmt :: Debug for ma_resampler__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_resampler__bindgen_ty_1 {{ union }}") } } impl :: core :: fmt :: Debug for ma_resampler { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_resampler {{ config: {:?}, state: {:?} }}" , self . config , self . state) } } extern "C" { pub fn ma_resampler_init (pConfig : * const ma_resampler_config , pResampler : * mut ma_resampler) -> ma_result ; } extern "C" { pub fn ma_resampler_uninit (pResampler : * mut ma_resampler) ; } extern "C" { pub fn ma_resampler_process_pcm_frames (pResampler : * mut ma_resampler , pFramesIn : * const libc :: c_void , pFrameCountIn : * mut ma_uint64 , pFramesOut : * mut libc :: c_void , pFrameCountOut : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_resampler_set_rate (pResampler : * mut ma_resampler , sampleRateIn : ma_uint32 , sampleRateOut : ma_uint32) -> ma_result ; } extern "C" { pub fn ma_resampler_set_rate_ratio (pResampler : * mut ma_resampler , ratio : f32) -> ma_result ; } extern "C" { pub fn ma_resampler_get_required_input_frame_count (pResampler : * mut ma_resampler , outputFrameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_resampler_get_expected_output_frame_count (pResampler : * mut ma_resampler , inputFrameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_resampler_get_input_latency (pResampler : * mut ma_resampler) -> ma_uint64 ; } extern "C" { pub fn ma_resampler_get_output_latency (pResampler : * mut ma_resampler) -> ma_uint64 ; } # [doc = "Channel Conversion"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_channel_converter_config { pub format : ma_format , pub channelsIn : ma_uint32 , pub channelsOut : ma_uint32 , pub channelMapIn : [ma_channel ; 32usize] , pub channelMapOut : [ma_channel ; 32usize] , pub mixingMode : ma_channel_mix_mode , pub weights : [[f32 ; 32usize] ; 32usize] , } extern "C" { pub fn ma_channel_converter_config_init (format : ma_format , channelsIn : ma_uint32 , pChannelMapIn : * const ma_channel , channelsOut : ma_uint32 , pChannelMapOut : * const ma_channel , mixingMode : ma_channel_mix_mode) -> ma_channel_converter_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_channel_converter { pub format : ma_format , pub channelsIn : ma_uint32 , pub channelsOut : ma_uint32 , pub channelMapIn : [ma_channel ; 32usize] , pub channelMapOut : [ma_channel ; 32usize] , pub mixingMode : ma_channel_mix_mode , pub weights : ma_channel_converter__bindgen_ty_1 , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub shuffleTable : [ma_uint8 ; 32usize] , } # [repr (C)] # [derive (Copy , Clone)] pub union ma_channel_converter__bindgen_ty_1 { pub f32_ : [[f32 ; 32usize] ; 32usize] , pub s16 : [[ma_int32 ; 32usize] ; 32usize] , _bindgen_union_align : [u32 ; 1024usize] , } impl :: core :: fmt :: Debug for ma_channel_converter__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_channel_converter__bindgen_ty_1 {{ union }}") } } impl :: core :: fmt :: Debug for ma_channel_converter { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_channel_converter {{ format: {:?}, channelsIn: {:?}, channelsOut: {:?}, channelMapIn: [...], channelMapOut: [...], mixingMode: {:?}, weights: {:?}, isPassthrough : {:?}, isSimpleShuffle : {:?}, isSimpleMonoExpansion : {:?}, isStereoToMono : {:?}, shuffleTable: [...] }}" , self . format , self . channelsIn , self . channelsOut , self . mixingMode , self . weights , self . isPassthrough () , self . isSimpleShuffle () , self . isSimpleMonoExpansion () , self . isStereoToMono ()) } } impl ma_channel_converter { # [inline] pub fn isPassthrough (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_isPassthrough (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn isSimpleShuffle (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_isSimpleShuffle (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn isSimpleMonoExpansion (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_isSimpleMonoExpansion (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn isStereoToMono (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_isStereoToMono (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (isPassthrough : ma_bool32 , isSimpleShuffle : ma_bool32 , isSimpleMonoExpansion : ma_bool32 , isStereoToMono : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let isPassthrough : u32 = unsafe { :: core :: mem :: transmute (isPassthrough) } ; isPassthrough as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let isSimpleShuffle : u32 = unsafe { :: core :: mem :: transmute (isSimpleShuffle) } ; isSimpleShuffle as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let isSimpleMonoExpansion : u32 = unsafe { :: core :: mem :: transmute (isSimpleMonoExpansion) } ; isSimpleMonoExpansion as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let isStereoToMono : u32 = unsafe { :: core :: mem :: transmute (isStereoToMono) } ; isStereoToMono as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn ma_channel_converter_init (pConfig : * const ma_channel_converter_config , pConverter : * mut ma_channel_converter) -> ma_result ; } extern "C" { pub fn ma_channel_converter_uninit (pConverter : * mut ma_channel_converter) ; } extern "C" { pub fn ma_channel_converter_process_pcm_frames (pConverter : * mut ma_channel_converter , pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_result ; } # [doc = "Data Conversion"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_data_converter_config { pub formatIn : ma_format , pub formatOut : ma_format , pub channelsIn : ma_uint32 , pub channelsOut : ma_uint32 , pub sampleRateIn : ma_uint32 , pub sampleRateOut : ma_uint32 , pub channelMapIn : [ma_channel ; 32usize] , pub channelMapOut : [ma_channel ; 32usize] , pub ditherMode : ma_dither_mode , pub channelMixMode : ma_channel_mix_mode , pub channelWeights : [[f32 ; 32usize] ; 32usize] , pub resampling : ma_data_converter_config__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_data_converter_config__bindgen_ty_1 { pub algorithm : ma_resample_algorithm , pub allowDynamicSampleRate : ma_bool32 , pub linear : ma_data_converter_config__bindgen_ty_1__bindgen_ty_1 , pub speex : ma_data_converter_config__bindgen_ty_1__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_data_converter_config__bindgen_ty_1__bindgen_ty_1 { pub lpfOrder : ma_uint32 , pub lpfNyquistFactor : f64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_data_converter_config__bindgen_ty_1__bindgen_ty_2 { pub quality : libc :: c_int , } extern "C" { pub fn ma_data_converter_config_init_default () -> ma_data_converter_config ; } extern "C" { pub fn ma_data_converter_config_init (formatIn : ma_format , formatOut : ma_format , channelsIn : ma_uint32 , channelsOut : ma_uint32 , sampleRateIn : ma_uint32 , sampleRateOut : ma_uint32) -> ma_data_converter_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_data_converter { pub config : ma_data_converter_config , pub channelConverter : ma_channel_converter , pub resampler : ma_resampler , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub __bindgen_padding_0 : [u8 ; 7usize] , } impl :: core :: fmt :: Debug for ma_data_converter { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_data_converter {{ config: {:?}, channelConverter: {:?}, resampler: {:?}, hasPreFormatConversion : {:?}, hasPostFormatConversion : {:?}, hasChannelConverter : {:?}, hasResampler : {:?}, isPassthrough : {:?} }}" , self . config , self . channelConverter , self . resampler , self . hasPreFormatConversion () , self . hasPostFormatConversion () , self . hasChannelConverter () , self . hasResampler () , self . isPassthrough ()) } } impl ma_data_converter { # [inline] pub fn hasPreFormatConversion (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_hasPreFormatConversion (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn hasPostFormatConversion (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_hasPostFormatConversion (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn hasChannelConverter (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_hasChannelConverter (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn hasResampler (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_hasResampler (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn isPassthrough (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_isPassthrough (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (hasPreFormatConversion : ma_bool32 , hasPostFormatConversion : ma_bool32 , hasChannelConverter : ma_bool32 , hasResampler : ma_bool32 , isPassthrough : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let hasPreFormatConversion : u32 = unsafe { :: core :: mem :: transmute (hasPreFormatConversion) } ; hasPreFormatConversion as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let hasPostFormatConversion : u32 = unsafe { :: core :: mem :: transmute (hasPostFormatConversion) } ; hasPostFormatConversion as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let hasChannelConverter : u32 = unsafe { :: core :: mem :: transmute (hasChannelConverter) } ; hasChannelConverter as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let hasResampler : u32 = unsafe { :: core :: mem :: transmute (hasResampler) } ; hasResampler as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let isPassthrough : u32 = unsafe { :: core :: mem :: transmute (isPassthrough) } ; isPassthrough as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn ma_data_converter_init (pConfig : * const ma_data_converter_config , pConverter : * mut ma_data_converter) -> ma_result ; } extern "C" { pub fn ma_data_converter_uninit (pConverter : * mut ma_data_converter) ; } extern "C" { pub fn ma_data_converter_process_pcm_frames (pConverter : * mut ma_data_converter , pFramesIn : * const libc :: c_void , pFrameCountIn : * mut ma_uint64 , pFramesOut : * mut libc :: c_void , pFrameCountOut : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_data_converter_set_rate (pConverter : * mut ma_data_converter , sampleRateIn : ma_uint32 , sampleRateOut : ma_uint32) -> ma_result ; } extern "C" { pub fn ma_data_converter_set_rate_ratio (pConverter : * mut ma_data_converter , ratioInOut : f32) -> ma_result ; } extern "C" { pub fn ma_data_converter_get_required_input_frame_count (pConverter : * mut ma_data_converter , outputFrameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_data_converter_get_expected_output_frame_count (pConverter : * mut ma_data_converter , inputFrameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_data_converter_get_input_latency (pConverter : * mut ma_data_converter) -> ma_uint64 ; } extern "C" { pub fn ma_data_converter_get_output_latency (pConverter : * mut ma_data_converter) -> ma_uint64 ; } extern "C" { # [doc = "Format Conversion"] pub fn ma_pcm_u8_to_s16 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_u8_to_s24 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_u8_to_s32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_u8_to_f32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s16_to_u8 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s16_to_s24 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s16_to_s32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s16_to_f32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s24_to_u8 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s24_to_s16 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s24_to_s32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s24_to_f32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s32_to_u8 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s32_to_s16 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s32_to_s24 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_s32_to_f32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_f32_to_u8 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_f32_to_s16 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_f32_to_s24 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_f32_to_s32 (pOut : * mut libc :: c_void , pIn : * const libc :: c_void , count : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_pcm_convert (pOut : * mut libc :: c_void , formatOut : ma_format , pIn : * const libc :: c_void , formatIn : ma_format , sampleCount : ma_uint64 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_convert_pcm_frames_format (pOut : * mut libc :: c_void , formatOut : ma_format , pIn : * const libc :: c_void , formatIn : ma_format , frameCount : ma_uint64 , channels : ma_uint32 , ditherMode : ma_dither_mode) ; } extern "C" { pub fn ma_deinterleave_pcm_frames (format : ma_format , channels : ma_uint32 , frameCount : ma_uint64 , pInterleavedPCMFrames : * const libc :: c_void , ppDeinterleavedPCMFrames : * mut * mut libc :: c_void) ; } extern "C" { pub fn ma_interleave_pcm_frames (format : ma_format , channels : ma_uint32 , frameCount : ma_uint64 , ppDeinterleavedPCMFrames : * mut * const libc :: c_void , pInterleavedPCMFrames : * mut libc :: c_void) ; } extern "C" { # [doc = "Channel Maps"] pub fn ma_get_standard_channel_map (standardChannelMap : ma_standard_channel_map , channels : ma_uint32 , pChannelMap : * mut ma_channel) ; } extern "C" { pub fn ma_channel_map_copy (pOut : * mut ma_channel , pIn : * const ma_channel , channels : ma_uint32) ; } extern "C" { pub fn ma_channel_map_copy_or_default (pOut : * mut ma_channel , pIn : * const ma_channel , channels : ma_uint32) ; } extern "C" { pub fn ma_channel_map_valid (channels : ma_uint32 , pChannelMap : * const ma_channel) -> ma_bool32 ; } extern "C" { pub fn ma_channel_map_equal (channels : ma_uint32 , pChannelMapA : * const ma_channel , pChannelMapB : * const ma_channel) -> ma_bool32 ; } extern "C" { pub fn ma_channel_map_blank (channels : ma_uint32 , pChannelMap : * const ma_channel) -> ma_bool32 ; } extern "C" { pub fn ma_channel_map_contains_channel_position (channels : ma_uint32 , pChannelMap : * const ma_channel , channelPosition : ma_channel) -> ma_bool32 ; } extern "C" { # [doc = "Conversion Helpers"] pub fn ma_convert_frames (pOut : * mut libc :: c_void , frameCountOut : ma_uint64 , formatOut : ma_format , channelsOut : ma_uint32 , sampleRateOut : ma_uint32 , pIn : * const libc :: c_void , frameCountIn : ma_uint64 , formatIn : ma_format , channelsIn : ma_uint32 , sampleRateIn : ma_uint32) -> ma_uint64 ; } extern "C" { pub fn ma_convert_frames_ex (pOut : * mut libc :: c_void , frameCountOut : ma_uint64 , pIn : * const libc :: c_void , frameCountIn : ma_uint64 , pConfig : * const ma_data_converter_config) -> ma_uint64 ; } # [doc = "Ring Buffer"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_rb { pub pBuffer : * mut libc :: c_void , pub subbufferSizeInBytes : ma_uint32 , pub subbufferCount : ma_uint32 , pub subbufferStrideInBytes : ma_uint32 , pub encodedReadOffset : ma_uint32 , pub encodedWriteOffset : ma_uint32 , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub allocationCallbacks : ma_allocation_callbacks , } impl ma_rb { # [inline] pub fn ownsBuffer (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_ownsBuffer (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn clearOnWriteAcquire (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_clearOnWriteAcquire (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (ownsBuffer : ma_bool32 , clearOnWriteAcquire : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let ownsBuffer : u32 = unsafe { :: core :: mem :: transmute (ownsBuffer) } ; ownsBuffer as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let clearOnWriteAcquire : u32 = unsafe { :: core :: mem :: transmute (clearOnWriteAcquire) } ; clearOnWriteAcquire as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn ma_rb_init_ex (subbufferSizeInBytes : usize , subbufferCount : usize , subbufferStrideInBytes : usize , pOptionalPreallocatedBuffer : * mut libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks , pRB : * mut ma_rb) -> ma_result ; } extern "C" { pub fn ma_rb_init (bufferSizeInBytes : usize , pOptionalPreallocatedBuffer : * mut libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks , pRB : * mut ma_rb) -> ma_result ; } extern "C" { pub fn ma_rb_uninit (pRB : * mut ma_rb) ; } extern "C" { pub fn ma_rb_reset (pRB : * mut ma_rb) ; } extern "C" { pub fn ma_rb_acquire_read (pRB : * mut ma_rb , pSizeInBytes : * mut usize , ppBufferOut : * mut * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_rb_commit_read (pRB : * mut ma_rb , sizeInBytes : usize , pBufferOut : * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_rb_acquire_write (pRB : * mut ma_rb , pSizeInBytes : * mut usize , ppBufferOut : * mut * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_rb_commit_write (pRB : * mut ma_rb , sizeInBytes : usize , pBufferOut : * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_rb_seek_read (pRB : * mut ma_rb , offsetInBytes : usize) -> ma_result ; } extern "C" { pub fn ma_rb_seek_write (pRB : * mut ma_rb , offsetInBytes : usize) -> ma_result ; } extern "C" { pub fn ma_rb_pointer_distance (pRB : * mut ma_rb) -> ma_int32 ; } extern "C" { pub fn ma_rb_available_read (pRB : * mut ma_rb) -> ma_uint32 ; } extern "C" { pub fn ma_rb_available_write (pRB : * mut ma_rb) -> ma_uint32 ; } extern "C" { pub fn ma_rb_get_subbuffer_size (pRB : * mut ma_rb) -> usize ; } extern "C" { pub fn ma_rb_get_subbuffer_stride (pRB : * mut ma_rb) -> usize ; } extern "C" { pub fn ma_rb_get_subbuffer_offset (pRB : * mut ma_rb , subbufferIndex : usize) -> usize ; } extern "C" { pub fn ma_rb_get_subbuffer_ptr (pRB : * mut ma_rb , subbufferIndex : usize , pBuffer : * mut libc :: c_void) -> * mut libc :: c_void ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_pcm_rb { pub rb : ma_rb , pub format : ma_format , pub channels : ma_uint32 , } extern "C" { pub fn ma_pcm_rb_init_ex (format : ma_format , channels : ma_uint32 , subbufferSizeInFrames : ma_uint32 , subbufferCount : ma_uint32 , subbufferStrideInFrames : ma_uint32 , pOptionalPreallocatedBuffer : * mut libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks , pRB : * mut ma_pcm_rb) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_init (format : ma_format , channels : ma_uint32 , bufferSizeInFrames : ma_uint32 , pOptionalPreallocatedBuffer : * mut libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks , pRB : * mut ma_pcm_rb) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_uninit (pRB : * mut ma_pcm_rb) ; } extern "C" { pub fn ma_pcm_rb_reset (pRB : * mut ma_pcm_rb) ; } extern "C" { pub fn ma_pcm_rb_acquire_read (pRB : * mut ma_pcm_rb , pSizeInFrames : * mut ma_uint32 , ppBufferOut : * mut * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_commit_read (pRB : * mut ma_pcm_rb , sizeInFrames : ma_uint32 , pBufferOut : * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_acquire_write (pRB : * mut ma_pcm_rb , pSizeInFrames : * mut ma_uint32 , ppBufferOut : * mut * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_commit_write (pRB : * mut ma_pcm_rb , sizeInFrames : ma_uint32 , pBufferOut : * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_seek_read (pRB : * mut ma_pcm_rb , offsetInFrames : ma_uint32) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_seek_write (pRB : * mut ma_pcm_rb , offsetInFrames : ma_uint32) -> ma_result ; } extern "C" { pub fn ma_pcm_rb_pointer_distance (pRB : * mut ma_pcm_rb) -> ma_int32 ; } extern "C" { pub fn ma_pcm_rb_available_read (pRB : * mut ma_pcm_rb) -> ma_uint32 ; } extern "C" { pub fn ma_pcm_rb_available_write (pRB : * mut ma_pcm_rb) -> ma_uint32 ; } extern "C" { pub fn ma_pcm_rb_get_subbuffer_size (pRB : * mut ma_pcm_rb) -> ma_uint32 ; } extern "C" { pub fn ma_pcm_rb_get_subbuffer_stride (pRB : * mut ma_pcm_rb) -> ma_uint32 ; } extern "C" { pub fn ma_pcm_rb_get_subbuffer_offset (pRB : * mut ma_pcm_rb , subbufferIndex : ma_uint32) -> ma_uint32 ; } extern "C" { pub fn ma_pcm_rb_get_subbuffer_ptr (pRB : * mut ma_pcm_rb , subbufferIndex : ma_uint32 , pBuffer : * mut libc :: c_void) -> * mut libc :: c_void ; } extern "C" { # [doc = "Miscellaneous Helpers"] pub fn ma_result_description (result : ma_result) -> * const libc :: c_char ; } extern "C" { pub fn ma_malloc (sz : usize , pAllocationCallbacks : * const ma_allocation_callbacks) -> * mut libc :: c_void ; } extern "C" { pub fn ma_realloc (p : * mut libc :: c_void , sz : usize , pAllocationCallbacks : * const ma_allocation_callbacks) -> * mut libc :: c_void ; } extern "C" { pub fn ma_free (p : * mut libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks) ; } extern "C" { pub fn ma_aligned_malloc (sz : usize , alignment : usize , pAllocationCallbacks : * const ma_allocation_callbacks) -> * mut libc :: c_void ; } extern "C" { pub fn ma_aligned_free (p : * mut libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks) ; } extern "C" { pub fn ma_get_format_name (format : ma_format) -> * const libc :: c_char ; } extern "C" { pub fn ma_blend_f32 (pOut : * mut f32 , pInA : * mut f32 , pInB : * mut f32 , factor : f32 , channels : ma_uint32) ; } extern "C" { pub fn ma_get_bytes_per_sample (format : ma_format) -> ma_uint32 ; } extern "C" { pub fn ma_log_level_to_string (logLevel : ma_uint32) -> * const libc :: c_char ; } pub const ma_backend_wasapi : ma_backend = 0 ; pub const ma_backend_dsound : ma_backend = 1 ; pub const ma_backend_winmm : ma_backend = 2 ; pub const ma_backend_coreaudio : ma_backend = 3 ; pub const ma_backend_sndio : ma_backend = 4 ; pub const ma_backend_audio4 : ma_backend = 5 ; pub const ma_backend_oss : ma_backend = 6 ; pub const ma_backend_pulseaudio : ma_backend = 7 ; pub const ma_backend_alsa : ma_backend = 8 ; pub const ma_backend_jack : ma_backend = 9 ; pub const ma_backend_aaudio : ma_backend = 10 ; pub const ma_backend_opensl : ma_backend = 11 ; pub const ma_backend_webaudio : ma_backend = 12 ; pub const ma_backend_null : ma_backend = 13 ; pub type ma_backend = libc :: c_uint ; pub type ma_device_callback_proc = :: core :: option :: Option < unsafe extern "C" fn (pDevice : * mut ma_device , pOutput : * mut libc :: c_void , pInput : * const libc :: c_void , frameCount : ma_uint32) > ; pub type ma_stop_proc = :: core :: option :: Option < unsafe extern "C" fn (pDevice : * mut ma_device) > ; pub type ma_log_proc = :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context , pDevice : * mut ma_device , logLevel : ma_uint32 , message : * const libc :: c_char) > ; pub const ma_device_type_playback : ma_device_type = 1 ; pub const ma_device_type_capture : ma_device_type = 2 ; pub const ma_device_type_duplex : ma_device_type = 3 ; pub const ma_device_type_loopback : ma_device_type = 4 ; pub type ma_device_type = libc :: c_uint ; pub const ma_share_mode_shared : ma_share_mode = 0 ; pub const ma_share_mode_exclusive : ma_share_mode = 1 ; pub type ma_share_mode = libc :: c_uint ; pub const ma_ios_session_category_default : ma_ios_session_category = 0 ; pub const ma_ios_session_category_none : ma_ios_session_category = 1 ; pub const ma_ios_session_category_ambient : ma_ios_session_category = 2 ; pub const ma_ios_session_category_solo_ambient : ma_ios_session_category = 3 ; pub const ma_ios_session_category_playback : ma_ios_session_category = 4 ; pub const ma_ios_session_category_record : ma_ios_session_category = 5 ; pub const ma_ios_session_category_play_and_record : ma_ios_session_category = 6 ; pub const ma_ios_session_category_multi_route : ma_ios_session_category = 7 ; pub type ma_ios_session_category = libc :: c_uint ; pub const ma_ios_session_category_option_mix_with_others : ma_ios_session_category_option = 1 ; pub const ma_ios_session_category_option_duck_others : ma_ios_session_category_option = 2 ; pub const ma_ios_session_category_option_allow_bluetooth : ma_ios_session_category_option = 4 ; pub const ma_ios_session_category_option_default_to_speaker : ma_ios_session_category_option = 8 ; pub const ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others : ma_ios_session_category_option = 17 ; pub const ma_ios_session_category_option_allow_bluetooth_a2dp : ma_ios_session_category_option = 32 ; pub const ma_ios_session_category_option_allow_air_play : ma_ios_session_category_option = 64 ; pub type ma_ios_session_category_option = libc :: c_uint ; # [repr (C)] # [derive (Copy , Clone)] pub union ma_timer { pub counter : ma_int64 , pub counterD : f64 , _bindgen_union_align : u64 , } impl :: core :: fmt :: Debug for ma_timer { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_timer {{ union }}") } } # [repr (C)] # [derive (Copy , Clone)] pub union ma_device_id { pub wasapi : [wchar_t ; 64usize] , pub dsound : [ma_uint8 ; 16usize] , pub winmm : ma_uint32 , pub alsa : [libc :: c_char ; 256usize] , pub pulse : [libc :: c_char ; 256usize] , pub jack : libc :: c_int , pub coreaudio : [libc :: c_char ; 256usize] , pub sndio : [libc :: c_char ; 256usize] , pub audio4 : [libc :: c_char ; 256usize] , pub oss : [libc :: c_char ; 64usize] , pub aaudio : ma_int32 , pub opensl : ma_uint32 , pub webaudio : [libc :: c_char ; 32usize] , pub nullbackend : libc :: c_int , _bindgen_union_align : [u32 ; 64usize] , } impl :: core :: fmt :: Debug for ma_device_id { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device_id {{ union }}") } } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_device_info { pub id : ma_device_id , pub name : [libc :: c_char ; 256usize] , pub formatCount : ma_uint32 , pub formats : [ma_format ; 6usize] , pub minChannels : ma_uint32 , pub maxChannels : ma_uint32 , pub minSampleRate : ma_uint32 , pub maxSampleRate : ma_uint32 , pub _private : ma_device_info__bindgen_ty_1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_info__bindgen_ty_1 { pub isDefault : ma_bool32 , } impl :: core :: fmt :: Debug for ma_device_info { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device_info {{ id: {:?}, name: [...], formatCount: {:?}, formats: {:?}, minChannels: {:?}, maxChannels: {:?}, minSampleRate: {:?}, maxSampleRate: {:?}, _private: {:?} }}" , self . id , self . formatCount , self . formats , self . minChannels , self . maxChannels , self . minSampleRate , self . maxSampleRate , self . _private) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config { pub deviceType : ma_device_type , pub sampleRate : ma_uint32 , pub periodSizeInFrames : ma_uint32 , pub periodSizeInMilliseconds : ma_uint32 , pub periods : ma_uint32 , pub performanceProfile : ma_performance_profile , pub noPreZeroedOutputBuffer : ma_bool32 , pub noClip : ma_bool32 , pub dataCallback : ma_device_callback_proc , pub stopCallback : ma_stop_proc , pub pUserData : * mut libc :: c_void , pub resampling : ma_device_config__bindgen_ty_1 , pub playback : ma_device_config__bindgen_ty_2 , pub capture : ma_device_config__bindgen_ty_3 , pub wasapi : ma_device_config__bindgen_ty_4 , pub alsa : ma_device_config__bindgen_ty_5 , pub pulse : ma_device_config__bindgen_ty_6 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_1 { pub algorithm : ma_resample_algorithm , pub linear : ma_device_config__bindgen_ty_1__bindgen_ty_1 , pub speex : ma_device_config__bindgen_ty_1__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_1__bindgen_ty_1 { pub lpfOrder : ma_uint32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_1__bindgen_ty_2 { pub quality : libc :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_2 { pub pDeviceID : * const ma_device_id , pub format : ma_format , pub channels : ma_uint32 , pub channelMap : [ma_channel ; 32usize] , pub shareMode : ma_share_mode , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_3 { pub pDeviceID : * const ma_device_id , pub format : ma_format , pub channels : ma_uint32 , pub channelMap : [ma_channel ; 32usize] , pub shareMode : ma_share_mode , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_4 { pub noAutoConvertSRC : ma_bool32 , pub noDefaultQualitySRC : ma_bool32 , pub noAutoStreamRouting : ma_bool32 , pub noHardwareOffloading : ma_bool32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_5 { pub noMMap : ma_bool32 , pub noAutoFormat : ma_bool32 , pub noAutoChannels : ma_bool32 , pub noAutoResample : ma_bool32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device_config__bindgen_ty_6 { pub pStreamNamePlayback : * const libc :: c_char , pub pStreamNameCapture : * const libc :: c_char , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context_config { pub logCallback : ma_log_proc , pub threadPriority : ma_thread_priority , pub threadStackSize : usize , pub pUserData : * mut libc :: c_void , pub allocationCallbacks : ma_allocation_callbacks , pub alsa : ma_context_config__bindgen_ty_1 , pub pulse : ma_context_config__bindgen_ty_2 , pub coreaudio : ma_context_config__bindgen_ty_3 , pub jack : ma_context_config__bindgen_ty_4 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context_config__bindgen_ty_1 { pub useVerboseDeviceEnumeration : ma_bool32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context_config__bindgen_ty_2 { pub pApplicationName : * const libc :: c_char , pub pServerName : * const libc :: c_char , pub tryAutoSpawn : ma_bool32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context_config__bindgen_ty_3 { pub sessionCategory : ma_ios_session_category , pub sessionCategoryOptions : ma_uint32 , pub noAudioSessionActivate : ma_bool32 , pub noAudioSessionDeactivate : ma_bool32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context_config__bindgen_ty_4 { pub pClientName : * const libc :: c_char , pub tryStartServer : ma_bool32 , } pub type ma_enum_devices_callback_proc = :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context , deviceType : ma_device_type , pInfo : * const ma_device_info , pUserData : * mut libc :: c_void) -> ma_bool32 > ; # [repr (C)] # [derive (Copy , Clone)] pub struct ma_context { pub backend : ma_backend , pub logCallback : ma_log_proc , pub threadPriority : ma_thread_priority , pub threadStackSize : usize , pub pUserData : * mut libc :: c_void , pub allocationCallbacks : ma_allocation_callbacks , pub deviceEnumLock : ma_mutex , pub deviceInfoLock : ma_mutex , pub deviceInfoCapacity : ma_uint32 , pub playbackDeviceInfoCount : ma_uint32 , pub captureDeviceInfoCount : ma_uint32 , pub pDeviceInfos : * mut ma_device_info , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub onUninit : :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context) -> ma_result > , pub onDeviceIDEqual : :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context , pID0 : * const ma_device_id , pID1 : * const ma_device_id) -> ma_bool32 > , pub onEnumDevices : :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context , callback : ma_enum_devices_callback_proc , pUserData : * mut libc :: c_void) -> ma_result > , pub onGetDeviceInfo : :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context , deviceType : ma_device_type , pDeviceID : * const ma_device_id , shareMode : ma_share_mode , pDeviceInfo : * mut ma_device_info) -> ma_result > , pub onDeviceInit : :: core :: option :: Option < unsafe extern "C" fn (pContext : * mut ma_context , pConfig : * const ma_device_config , pDevice : * mut ma_device) -> ma_result > , pub onDeviceUninit : :: core :: option :: Option < unsafe extern "C" fn (pDevice : * mut ma_device) > , pub onDeviceStart : :: core :: option :: Option < unsafe extern "C" fn (pDevice : * mut ma_device) -> ma_result > , pub onDeviceStop : :: core :: option :: Option < unsafe extern "C" fn (pDevice : * mut ma_device) -> ma_result > , pub onDeviceMainLoop : :: core :: option :: Option < unsafe extern "C" fn (pDevice : * mut ma_device) -> ma_result > , pub __bindgen_anon_1 : ma_context__bindgen_ty_1 , pub __bindgen_anon_2 : ma_context__bindgen_ty_2 , } # [repr (C)] # [derive (Copy , Clone)] pub union ma_context__bindgen_ty_1 { pub coreaudio : ma_context__bindgen_ty_1__bindgen_ty_1 , pub null_backend : ma_context__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [u64 ; 23usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context__bindgen_ty_1__bindgen_ty_1 { pub hCoreFoundation : ma_handle , pub CFStringGetCString : ma_proc , pub CFRelease : ma_proc , pub hCoreAudio : ma_handle , pub AudioObjectGetPropertyData : ma_proc , pub AudioObjectGetPropertyDataSize : ma_proc , pub AudioObjectSetPropertyData : ma_proc , pub AudioObjectAddPropertyListener : ma_proc , pub AudioObjectRemovePropertyListener : ma_proc , pub hAudioUnit : ma_handle , pub AudioComponentFindNext : ma_proc , pub AudioComponentInstanceDispose : ma_proc , pub AudioComponentInstanceNew : ma_proc , pub AudioOutputUnitStart : ma_proc , pub AudioOutputUnitStop : ma_proc , pub AudioUnitAddPropertyListener : ma_proc , pub AudioUnitGetPropertyInfo : ma_proc , pub AudioUnitGetProperty : ma_proc , pub AudioUnitSetProperty : ma_proc , pub AudioUnitInitialize : ma_proc , pub AudioUnitRender : ma_proc , pub component : ma_ptr , pub noAudioSessionDeactivate : ma_bool32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context__bindgen_ty_1__bindgen_ty_2 { pub _unused : libc :: c_int , } impl :: core :: fmt :: Debug for ma_context__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_context__bindgen_ty_1 {{ union }}") } } # [repr (C)] # [derive (Copy , Clone)] pub union ma_context__bindgen_ty_2 { pub posix : ma_context__bindgen_ty_2__bindgen_ty_1 , pub _unused : libc :: c_int , _bindgen_union_align : [u64 ; 16usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_context__bindgen_ty_2__bindgen_ty_1 { pub pthreadSO : ma_handle , pub pthread_create : ma_proc , pub pthread_join : ma_proc , pub pthread_mutex_init : ma_proc , pub pthread_mutex_destroy : ma_proc , pub pthread_mutex_lock : ma_proc , pub pthread_mutex_unlock : ma_proc , pub pthread_cond_init : ma_proc , pub pthread_cond_destroy : ma_proc , pub pthread_cond_wait : ma_proc , pub pthread_cond_signal : ma_proc , pub pthread_attr_init : ma_proc , pub pthread_attr_destroy : ma_proc , pub pthread_attr_setschedpolicy : ma_proc , pub pthread_attr_getschedparam : ma_proc , pub pthread_attr_setschedparam : ma_proc , } impl :: core :: fmt :: Debug for ma_context__bindgen_ty_2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_context__bindgen_ty_2 {{ union }}") } } impl :: core :: fmt :: Debug for ma_context { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_context {{ backend: {:?}, logCallback: {:?}, threadPriority: {:?}, threadStackSize: {:?}, pUserData: {:?}, allocationCallbacks: {:?}, deviceEnumLock: {:?}, deviceInfoLock: {:?}, deviceInfoCapacity: {:?}, playbackDeviceInfoCount: {:?}, captureDeviceInfoCount: {:?}, pDeviceInfos: {:?}, isBackendAsynchronous : {:?}, onUninit: {:?}, onDeviceIDEqual: {:?}, onEnumDevices: {:?}, onGetDeviceInfo: {:?}, onDeviceInit: {:?}, onDeviceUninit: {:?}, onDeviceStart: {:?}, onDeviceStop: {:?}, onDeviceMainLoop: {:?}, __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?} }}" , self . backend , self . logCallback , self . threadPriority , self . threadStackSize , self . pUserData , self . allocationCallbacks , self . deviceEnumLock , self . deviceInfoLock , self . deviceInfoCapacity , self . playbackDeviceInfoCount , self . captureDeviceInfoCount , self . pDeviceInfos , self . isBackendAsynchronous () , self . onUninit , self . onDeviceIDEqual , self . onEnumDevices , self . onGetDeviceInfo , self . onDeviceInit , self . onDeviceUninit , self . onDeviceStart , self . onDeviceStop , self . onDeviceMainLoop , self . __bindgen_anon_1 , self . __bindgen_anon_2) } } impl ma_context { # [inline] pub fn isBackendAsynchronous (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_isBackendAsynchronous (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (isBackendAsynchronous : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let isBackendAsynchronous : u32 = unsafe { :: core :: mem :: transmute (isBackendAsynchronous) } ; isBackendAsynchronous as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_device { pub pContext : * mut ma_context , pub type_ : ma_device_type , pub sampleRate : ma_uint32 , pub state : ma_uint32 , pub onData : ma_device_callback_proc , pub onStop : ma_stop_proc , pub pUserData : * mut libc :: c_void , pub lock : ma_mutex , pub wakeupEvent : ma_event , pub startEvent : ma_event , pub stopEvent : ma_event , pub thread : ma_thread , pub workResult : ma_result , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub masterVolumeFactor : f32 , pub resampling : ma_device__bindgen_ty_1 , pub playback : ma_device__bindgen_ty_2 , pub capture : ma_device__bindgen_ty_3 , pub __bindgen_anon_1 : ma_device__bindgen_ty_4 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device__bindgen_ty_1 { pub algorithm : ma_resample_algorithm , pub linear : ma_device__bindgen_ty_1__bindgen_ty_1 , pub speex : ma_device__bindgen_ty_1__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device__bindgen_ty_1__bindgen_ty_1 { pub lpfOrder : ma_uint32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_device__bindgen_ty_1__bindgen_ty_2 { pub quality : libc :: c_int , } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_device__bindgen_ty_2 { pub id : ma_device_id , pub name : [libc :: c_char ; 256usize] , pub shareMode : ma_share_mode , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub format : ma_format , pub channels : ma_uint32 , pub channelMap : [ma_channel ; 32usize] , pub internalFormat : ma_format , pub internalChannels : ma_uint32 , pub internalSampleRate : ma_uint32 , pub internalChannelMap : [ma_channel ; 32usize] , pub internalPeriodSizeInFrames : ma_uint32 , pub internalPeriods : ma_uint32 , pub converter : ma_data_converter , } impl :: core :: fmt :: Debug for ma_device__bindgen_ty_2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device__bindgen_ty_2 {{ id: {:?}, name: [...], shareMode: {:?}, usingDefaultFormat : {:?}, usingDefaultChannels : {:?}, usingDefaultChannelMap : {:?}, format: {:?}, channels: {:?}, channelMap: [...], internalFormat: {:?}, internalChannels: {:?}, internalSampleRate: {:?}, internalChannelMap: [...], internalPeriodSizeInFrames: {:?}, internalPeriods: {:?}, converter: {:?} }}" , self . id , self . shareMode , self . usingDefaultFormat () , self . usingDefaultChannels () , self . usingDefaultChannelMap () , self . format , self . channels , self . internalFormat , self . internalChannels , self . internalSampleRate , self . internalPeriodSizeInFrames , self . internalPeriods , self . converter) } } impl ma_device__bindgen_ty_2 { # [inline] pub fn usingDefaultFormat (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultFormat (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn usingDefaultChannels (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultChannels (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn usingDefaultChannelMap (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultChannelMap (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (usingDefaultFormat : ma_bool32 , usingDefaultChannels : ma_bool32 , usingDefaultChannelMap : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let usingDefaultFormat : u32 = unsafe { :: core :: mem :: transmute (usingDefaultFormat) } ; usingDefaultFormat as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let usingDefaultChannels : u32 = unsafe { :: core :: mem :: transmute (usingDefaultChannels) } ; usingDefaultChannels as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let usingDefaultChannelMap : u32 = unsafe { :: core :: mem :: transmute (usingDefaultChannelMap) } ; usingDefaultChannelMap as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_device__bindgen_ty_3 { pub id : ma_device_id , pub name : [libc :: c_char ; 256usize] , pub shareMode : ma_share_mode , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > , pub format : ma_format , pub channels : ma_uint32 , pub channelMap : [ma_channel ; 32usize] , pub internalFormat : ma_format , pub internalChannels : ma_uint32 , pub internalSampleRate : ma_uint32 , pub internalChannelMap : [ma_channel ; 32usize] , pub internalPeriodSizeInFrames : ma_uint32 , pub internalPeriods : ma_uint32 , pub converter : ma_data_converter , } impl :: core :: fmt :: Debug for ma_device__bindgen_ty_3 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device__bindgen_ty_3 {{ id: {:?}, name: [...], shareMode: {:?}, usingDefaultFormat : {:?}, usingDefaultChannels : {:?}, usingDefaultChannelMap : {:?}, format: {:?}, channels: {:?}, channelMap: [...], internalFormat: {:?}, internalChannels: {:?}, internalSampleRate: {:?}, internalChannelMap: [...], internalPeriodSizeInFrames: {:?}, internalPeriods: {:?}, converter: {:?} }}" , self . id , self . shareMode , self . usingDefaultFormat () , self . usingDefaultChannels () , self . usingDefaultChannelMap () , self . format , self . channels , self . internalFormat , self . internalChannels , self . internalSampleRate , self . internalPeriodSizeInFrames , self . internalPeriods , self . converter) } } impl ma_device__bindgen_ty_3 { # [inline] pub fn usingDefaultFormat (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultFormat (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn usingDefaultChannels (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultChannels (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn usingDefaultChannelMap (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultChannelMap (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (usingDefaultFormat : ma_bool32 , usingDefaultChannels : ma_bool32 , usingDefaultChannelMap : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let usingDefaultFormat : u32 = unsafe { :: core :: mem :: transmute (usingDefaultFormat) } ; usingDefaultFormat as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let usingDefaultChannels : u32 = unsafe { :: core :: mem :: transmute (usingDefaultChannels) } ; usingDefaultChannels as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let usingDefaultChannelMap : u32 = unsafe { :: core :: mem :: transmute (usingDefaultChannelMap) } ; usingDefaultChannelMap as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] pub union ma_device__bindgen_ty_4 { pub coreaudio : ma_device__bindgen_ty_4__bindgen_ty_1 , pub null_device : ma_device__bindgen_ty_4__bindgen_ty_2 , _bindgen_union_align : [u64 ; 37usize] , } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_device__bindgen_ty_4__bindgen_ty_1 { pub deviceObjectIDPlayback : ma_uint32 , pub deviceObjectIDCapture : ma_uint32 , pub audioUnitPlayback : ma_ptr , pub audioUnitCapture : ma_ptr , pub pAudioBufferList : ma_ptr , pub stopEvent : ma_event , pub originalPeriodSizeInFrames : ma_uint32 , pub originalPeriodSizeInMilliseconds : ma_uint32 , pub originalPeriods : ma_uint32 , pub isDefaultPlaybackDevice : ma_bool32 , pub isDefaultCaptureDevice : ma_bool32 , pub isSwitchingPlaybackDevice : ma_bool32 , pub isSwitchingCaptureDevice : ma_bool32 , pub duplexRB : ma_pcm_rb , pub pRouteChangeHandler : * mut libc :: c_void , } impl :: core :: fmt :: Debug for ma_device__bindgen_ty_4__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device__bindgen_ty_4__bindgen_ty_1 {{ deviceObjectIDPlayback: {:?}, deviceObjectIDCapture: {:?}, audioUnitPlayback: {:?}, audioUnitCapture: {:?}, pAudioBufferList: {:?}, stopEvent: {:?}, originalPeriodSizeInFrames: {:?}, originalPeriodSizeInMilliseconds: {:?}, originalPeriods: {:?}, isDefaultPlaybackDevice: {:?}, isDefaultCaptureDevice: {:?}, isSwitchingPlaybackDevice: {:?}, isSwitchingCaptureDevice: {:?}, duplexRB: {:?}, pRouteChangeHandler: {:?} }}" , self . deviceObjectIDPlayback , self . deviceObjectIDCapture , self . audioUnitPlayback , self . audioUnitCapture , self . pAudioBufferList , self . stopEvent , self . originalPeriodSizeInFrames , self . originalPeriodSizeInMilliseconds , self . originalPeriods , self . isDefaultPlaybackDevice , self . isDefaultCaptureDevice , self . isSwitchingPlaybackDevice , self . isSwitchingCaptureDevice , self . duplexRB , self . pRouteChangeHandler) } } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_device__bindgen_ty_4__bindgen_ty_2 { pub deviceThread : ma_thread , pub operationEvent : ma_event , pub operationCompletionEvent : ma_event , pub operation : ma_uint32 , pub operationResult : ma_result , pub timer : ma_timer , pub priorRunTime : f64 , pub currentPeriodFramesRemainingPlayback : ma_uint32 , pub currentPeriodFramesRemainingCapture : ma_uint32 , pub lastProcessedFramePlayback : ma_uint64 , pub lastProcessedFrameCapture : ma_uint32 , pub isStarted : ma_bool32 , } impl :: core :: fmt :: Debug for ma_device__bindgen_ty_4__bindgen_ty_2 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device__bindgen_ty_4__bindgen_ty_2 {{ deviceThread: {:?}, operationEvent: {:?}, operationCompletionEvent: {:?}, operation: {:?}, operationResult: {:?}, timer: {:?}, priorRunTime: {:?}, currentPeriodFramesRemainingPlayback: {:?}, currentPeriodFramesRemainingCapture: {:?}, lastProcessedFramePlayback: {:?}, lastProcessedFrameCapture: {:?}, isStarted: {:?} }}" , self . deviceThread , self . operationEvent , self . operationCompletionEvent , self . operation , self . operationResult , self . timer , self . priorRunTime , self . currentPeriodFramesRemainingPlayback , self . currentPeriodFramesRemainingCapture , self . lastProcessedFramePlayback , self . lastProcessedFrameCapture , self . isStarted) } } impl :: core :: fmt :: Debug for ma_device__bindgen_ty_4 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device__bindgen_ty_4 {{ union }}") } } impl :: core :: fmt :: Debug for ma_device { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_device {{ pContext: {:?}, type: {:?}, sampleRate: {:?}, state: {:?}, onData: {:?}, onStop: {:?}, pUserData: {:?}, lock: {:?}, wakeupEvent: {:?}, startEvent: {:?}, stopEvent: {:?}, thread: {:?}, workResult: {:?}, usingDefaultSampleRate : {:?}, usingDefaultBufferSize : {:?}, usingDefaultPeriods : {:?}, isOwnerOfContext : {:?}, noPreZeroedOutputBuffer : {:?}, noClip : {:?}, masterVolumeFactor: {:?}, resampling: {:?}, playback: {:?}, capture: {:?}, __bindgen_anon_1: {:?} }}" , self . pContext , self . type_ , self . sampleRate , self . state , self . onData , self . onStop , self . pUserData , self . lock , self . wakeupEvent , self . startEvent , self . stopEvent , self . thread , self . workResult , self . usingDefaultSampleRate () , self . usingDefaultBufferSize () , self . usingDefaultPeriods () , self . isOwnerOfContext () , self . noPreZeroedOutputBuffer () , self . noClip () , self . masterVolumeFactor , self . resampling , self . playback , self . capture , self . __bindgen_anon_1) } } impl ma_device { # [inline] pub fn usingDefaultSampleRate (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultSampleRate (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn usingDefaultBufferSize (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultBufferSize (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn usingDefaultPeriods (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_usingDefaultPeriods (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn isOwnerOfContext (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (3usize , 1u8) as u32) } } # [inline] pub fn set_isOwnerOfContext (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (3usize , 1u8 , val as u64) } } # [inline] pub fn noPreZeroedOutputBuffer (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (4usize , 1u8) as u32) } } # [inline] pub fn set_noPreZeroedOutputBuffer (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 1u8 , val as u64) } } # [inline] pub fn noClip (& self) -> ma_bool32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (5usize , 1u8) as u32) } } # [inline] pub fn set_noClip (& mut self , val : ma_bool32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (5usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (usingDefaultSampleRate : ma_bool32 , usingDefaultBufferSize : ma_bool32 , usingDefaultPeriods : ma_bool32 , isOwnerOfContext : ma_bool32 , noPreZeroedOutputBuffer : ma_bool32 , noClip : ma_bool32) -> __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] , u8 > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let usingDefaultSampleRate : u32 = unsafe { :: core :: mem :: transmute (usingDefaultSampleRate) } ; usingDefaultSampleRate as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let usingDefaultBufferSize : u32 = unsafe { :: core :: mem :: transmute (usingDefaultBufferSize) } ; usingDefaultBufferSize as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let usingDefaultPeriods : u32 = unsafe { :: core :: mem :: transmute (usingDefaultPeriods) } ; usingDefaultPeriods as u64 }) ; __bindgen_bitfield_unit . set (3usize , 1u8 , { let isOwnerOfContext : u32 = unsafe { :: core :: mem :: transmute (isOwnerOfContext) } ; isOwnerOfContext as u64 }) ; __bindgen_bitfield_unit . set (4usize , 1u8 , { let noPreZeroedOutputBuffer : u32 = unsafe { :: core :: mem :: transmute (noPreZeroedOutputBuffer) } ; noPreZeroedOutputBuffer as u64 }) ; __bindgen_bitfield_unit . set (5usize , 1u8 , { let noClip : u32 = unsafe { :: core :: mem :: transmute (noClip) } ; noClip as u64 }) ; __bindgen_bitfield_unit } } extern "C" { pub fn ma_context_config_init () -> ma_context_config ; } extern "C" { pub fn ma_context_init (backends : * const ma_backend , backendCount : ma_uint32 , pConfig : * const ma_context_config , pContext : * mut ma_context) -> ma_result ; } extern "C" { pub fn ma_context_uninit (pContext : * mut ma_context) -> ma_result ; } extern "C" { pub fn ma_context_sizeof () -> usize ; } extern "C" { pub fn ma_context_enumerate_devices (pContext : * mut ma_context , callback : ma_enum_devices_callback_proc , pUserData : * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_context_get_devices (pContext : * mut ma_context , ppPlaybackDeviceInfos : * mut * mut ma_device_info , pPlaybackDeviceCount : * mut ma_uint32 , ppCaptureDeviceInfos : * mut * mut ma_device_info , pCaptureDeviceCount : * mut ma_uint32) -> ma_result ; } extern "C" { pub fn ma_context_get_device_info (pContext : * mut ma_context , deviceType : ma_device_type , pDeviceID : * const ma_device_id , shareMode : ma_share_mode , pDeviceInfo : * mut ma_device_info) -> ma_result ; } extern "C" { pub fn ma_context_is_loopback_supported (pContext : * mut ma_context) -> ma_bool32 ; } extern "C" { pub fn ma_device_config_init (deviceType : ma_device_type) -> ma_device_config ; } extern "C" { pub fn ma_device_init (pContext : * mut ma_context , pConfig : * const ma_device_config , pDevice : * mut ma_device) -> ma_result ; } extern "C" { pub fn ma_device_init_ex (backends : * const ma_backend , backendCount : ma_uint32 , pContextConfig : * const ma_context_config , pConfig : * const ma_device_config , pDevice : * mut ma_device) -> ma_result ; } extern "C" { pub fn ma_device_uninit (pDevice : * mut ma_device) ; } extern "C" { pub fn ma_device_start (pDevice : * mut ma_device) -> ma_result ; } extern "C" { pub fn ma_device_stop (pDevice : * mut ma_device) -> ma_result ; } extern "C" { pub fn ma_device_is_started (pDevice : * mut ma_device) -> ma_bool32 ; } extern "C" { pub fn ma_device_set_master_volume (pDevice : * mut ma_device , volume : f32) -> ma_result ; } extern "C" { pub fn ma_device_get_master_volume (pDevice : * mut ma_device , pVolume : * mut f32) -> ma_result ; } extern "C" { pub fn ma_device_set_master_gain_db (pDevice : * mut ma_device , gainDB : f32) -> ma_result ; } extern "C" { pub fn ma_device_get_master_gain_db (pDevice : * mut ma_device , pGainDB : * mut f32) -> ma_result ; } extern "C" { pub fn ma_get_backend_name (backend : ma_backend) -> * const libc :: c_char ; } extern "C" { pub fn ma_is_loopback_supported (backend : ma_backend) -> ma_bool32 ; } extern "C" { pub fn ma_spinlock_lock (pSpinlock : * mut ma_spinlock) -> ma_result ; } extern "C" { pub fn ma_spinlock_lock_noyield (pSpinlock : * mut ma_spinlock) -> ma_result ; } extern "C" { pub fn ma_spinlock_unlock (pSpinlock : * mut ma_spinlock) -> ma_result ; } extern "C" { pub fn ma_mutex_init (pMutex : * mut ma_mutex) -> ma_result ; } extern "C" { pub fn ma_mutex_uninit (pMutex : * mut ma_mutex) ; } extern "C" { pub fn ma_mutex_lock (pMutex : * mut ma_mutex) ; } extern "C" { pub fn ma_mutex_unlock (pMutex : * mut ma_mutex) ; } extern "C" { pub fn ma_event_init (pEvent : * mut ma_event) -> ma_result ; } extern "C" { pub fn ma_event_uninit (pEvent : * mut ma_event) ; } extern "C" { pub fn ma_event_wait (pEvent : * mut ma_event) -> ma_result ; } extern "C" { pub fn ma_event_signal (pEvent : * mut ma_event) -> ma_result ; } extern "C" { # [doc = "Utiltities"] pub fn ma_scale_buffer_size (baseBufferSize : ma_uint32 , scale : f32) -> ma_uint32 ; } extern "C" { pub fn ma_calculate_buffer_size_in_milliseconds_from_frames (bufferSizeInFrames : ma_uint32 , sampleRate : ma_uint32) -> ma_uint32 ; } extern "C" { pub fn ma_calculate_buffer_size_in_frames_from_milliseconds (bufferSizeInMilliseconds : ma_uint32 , sampleRate : ma_uint32) -> ma_uint32 ; } extern "C" { pub fn ma_copy_pcm_frames (dst : * mut libc :: c_void , src : * const libc :: c_void , frameCount : ma_uint64 , format : ma_format , channels : ma_uint32) ; } extern "C" { pub fn ma_silence_pcm_frames (p : * mut libc :: c_void , frameCount : ma_uint64 , format : ma_format , channels : ma_uint32) ; } extern "C" { pub fn ma_offset_pcm_frames_ptr (p : * mut libc :: c_void , offsetInFrames : ma_uint64 , format : ma_format , channels : ma_uint32) -> * mut libc :: c_void ; } extern "C" { pub fn ma_offset_pcm_frames_const_ptr (p : * const libc :: c_void , offsetInFrames : ma_uint64 , format : ma_format , channels : ma_uint32) -> * const libc :: c_void ; } extern "C" { pub fn ma_clip_samples_f32 (p : * mut f32 , sampleCount : ma_uint64) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_u8 (pSamplesOut : * mut ma_uint8 , pSamplesIn : * const ma_uint8 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_s16 (pSamplesOut : * mut ma_int16 , pSamplesIn : * const ma_int16 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_s24 (pSamplesOut : * mut libc :: c_void , pSamplesIn : * const libc :: c_void , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_s32 (pSamplesOut : * mut ma_int32 , pSamplesIn : * const ma_int32 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_f32 (pSamplesOut : * mut f32 , pSamplesIn : * const f32 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_u8 (pSamples : * mut ma_uint8 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_s16 (pSamples : * mut ma_int16 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_s24 (pSamples : * mut libc :: c_void , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_s32 (pSamples : * mut ma_int32 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_f32 (pSamples : * mut f32 , sampleCount : ma_uint64 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_pcm_frames_u8 (pPCMFramesOut : * mut ma_uint8 , pPCMFramesIn : * const ma_uint8 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_pcm_frames_s16 (pPCMFramesOut : * mut ma_int16 , pPCMFramesIn : * const ma_int16 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_pcm_frames_s24 (pPCMFramesOut : * mut libc :: c_void , pPCMFramesIn : * const libc :: c_void , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_pcm_frames_s32 (pPCMFramesOut : * mut ma_int32 , pPCMFramesIn : * const ma_int32 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_pcm_frames_f32 (pPCMFramesOut : * mut f32 , pPCMFramesIn : * const f32 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_copy_and_apply_volume_factor_pcm_frames (pFramesOut : * mut libc :: c_void , pFramesIn : * const libc :: c_void , frameCount : ma_uint64 , format : ma_format , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_pcm_frames_u8 (pFrames : * mut ma_uint8 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_pcm_frames_s16 (pFrames : * mut ma_int16 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_pcm_frames_s24 (pFrames : * mut libc :: c_void , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_pcm_frames_s32 (pFrames : * mut ma_int32 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_pcm_frames_f32 (pFrames : * mut f32 , frameCount : ma_uint64 , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_apply_volume_factor_pcm_frames (pFrames : * mut libc :: c_void , frameCount : ma_uint64 , format : ma_format , channels : ma_uint32 , factor : f32) ; } extern "C" { pub fn ma_factor_to_gain_db (factor : f32) -> f32 ; } extern "C" { pub fn ma_gain_db_to_factor (gain : f32) -> f32 ; } pub type ma_data_source = libc :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_data_source_callbacks { pub onRead : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64 , pFramesRead : * mut ma_uint64) -> ma_result > , pub onSeek : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , frameIndex : ma_uint64) -> ma_result > , pub onMap : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , ppFramesOut : * mut * mut libc :: c_void , pFrameCount : * mut ma_uint64) -> ma_result > , pub onUnmap : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , frameCount : ma_uint64) -> ma_result > , pub onGetDataFormat : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , pFormat : * mut ma_format , pChannels : * mut ma_uint32 , pSampleRate : * mut ma_uint32) -> ma_result > , pub onGetCursor : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , pCursor : * mut ma_uint64) -> ma_result > , pub onGetLength : :: core :: option :: Option < unsafe extern "C" fn (pDataSource : * mut ma_data_source , pLength : * mut ma_uint64) -> ma_result > , } extern "C" { pub fn ma_data_source_read_pcm_frames (pDataSource : * mut ma_data_source , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64 , pFramesRead : * mut ma_uint64 , loop_ : ma_bool32) -> ma_result ; } extern "C" { pub fn ma_data_source_seek_pcm_frames (pDataSource : * mut ma_data_source , frameCount : ma_uint64 , pFramesSeeked : * mut ma_uint64 , loop_ : ma_bool32) -> ma_result ; } extern "C" { pub fn ma_data_source_seek_to_pcm_frame (pDataSource : * mut ma_data_source , frameIndex : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_data_source_map (pDataSource : * mut ma_data_source , ppFramesOut : * mut * mut libc :: c_void , pFrameCount : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_data_source_unmap (pDataSource : * mut ma_data_source , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_data_source_get_data_format (pDataSource : * mut ma_data_source , pFormat : * mut ma_format , pChannels : * mut ma_uint32 , pSampleRate : * mut ma_uint32) -> ma_result ; } extern "C" { pub fn ma_data_source_get_cursor_in_pcm_frames (pDataSource : * mut ma_data_source , pCursor : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_data_source_get_length_in_pcm_frames (pDataSource : * mut ma_data_source , pLength : * mut ma_uint64) -> ma_result ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_audio_buffer_config { pub format : ma_format , pub channels : ma_uint32 , pub sizeInFrames : ma_uint64 , pub pData : * const libc :: c_void , pub allocationCallbacks : ma_allocation_callbacks , } extern "C" { pub fn ma_audio_buffer_config_init (format : ma_format , channels : ma_uint32 , sizeInFrames : ma_uint64 , pData : * const libc :: c_void , pAllocationCallbacks : * const ma_allocation_callbacks) -> ma_audio_buffer_config ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_audio_buffer { pub ds : ma_data_source_callbacks , pub format : ma_format , pub channels : ma_uint32 , pub cursor : ma_uint64 , pub sizeInFrames : ma_uint64 , pub pData : * const libc :: c_void , pub allocationCallbacks : ma_allocation_callbacks , pub ownsData : ma_bool32 , pub _pExtraData : [ma_uint8 ; 1usize] , } extern "C" { pub fn ma_audio_buffer_init (pConfig : * const ma_audio_buffer_config , pAudioBuffer : * mut ma_audio_buffer) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_init_copy (pConfig : * const ma_audio_buffer_config , pAudioBuffer : * mut ma_audio_buffer) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_alloc_and_init (pConfig : * const ma_audio_buffer_config , ppAudioBuffer : * mut * mut ma_audio_buffer) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_uninit (pAudioBuffer : * mut ma_audio_buffer) ; } extern "C" { pub fn ma_audio_buffer_uninit_and_free (pAudioBuffer : * mut ma_audio_buffer) ; } extern "C" { pub fn ma_audio_buffer_read_pcm_frames (pAudioBuffer : * mut ma_audio_buffer , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64 , loop_ : ma_bool32) -> ma_uint64 ; } extern "C" { pub fn ma_audio_buffer_seek_to_pcm_frame (pAudioBuffer : * mut ma_audio_buffer , frameIndex : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_map (pAudioBuffer : * mut ma_audio_buffer , ppFramesOut : * mut * mut libc :: c_void , pFrameCount : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_unmap (pAudioBuffer : * mut ma_audio_buffer , frameCount : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_at_end (pAudioBuffer : * mut ma_audio_buffer) -> ma_result ; } extern "C" { pub fn ma_audio_buffer_get_available_frames (pAudioBuffer : * mut ma_audio_buffer , pAvailableFrames : * mut ma_uint64) -> ma_result ; } # [doc = "VFS"] # [doc = "==="] # [doc = ""] # [doc = "The VFS object (virtual file system) is what's used to customize file access. This is useful in cases where stdio FILE* based APIs may not be entirely"] # [doc = "appropriate for a given situation."] pub type ma_vfs = libc :: c_void ; pub type ma_vfs_file = ma_handle ; pub const ma_seek_origin_start : ma_seek_origin = 0 ; pub const ma_seek_origin_current : ma_seek_origin = 1 ; pub const ma_seek_origin_end : ma_seek_origin = 2 ; pub type ma_seek_origin = libc :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_file_info { pub sizeInBytes : ma_uint64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_vfs_callbacks { pub onOpen : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , openMode : ma_uint32 , pFile : * mut ma_vfs_file) -> ma_result > , pub onOpenW : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , openMode : ma_uint32 , pFile : * mut ma_vfs_file) -> ma_result > , pub onClose : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , file : ma_vfs_file) -> ma_result > , pub onRead : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , file : ma_vfs_file , pDst : * mut libc :: c_void , sizeInBytes : usize , pBytesRead : * mut usize) -> ma_result > , pub onWrite : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , file : ma_vfs_file , pSrc : * const libc :: c_void , sizeInBytes : usize , pBytesWritten : * mut usize) -> ma_result > , pub onSeek : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , file : ma_vfs_file , offset : ma_int64 , origin : ma_seek_origin) -> ma_result > , pub onTell : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , file : ma_vfs_file , pCursor : * mut ma_int64) -> ma_result > , pub onInfo : :: core :: option :: Option < unsafe extern "C" fn (pVFS : * mut ma_vfs , file : ma_vfs_file , pInfo : * mut ma_file_info) -> ma_result > , } extern "C" { pub fn ma_vfs_open (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , openMode : ma_uint32 , pFile : * mut ma_vfs_file) -> ma_result ; } extern "C" { pub fn ma_vfs_open_w (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , openMode : ma_uint32 , pFile : * mut ma_vfs_file) -> ma_result ; } extern "C" { pub fn ma_vfs_close (pVFS : * mut ma_vfs , file : ma_vfs_file) -> ma_result ; } extern "C" { pub fn ma_vfs_read (pVFS : * mut ma_vfs , file : ma_vfs_file , pDst : * mut libc :: c_void , sizeInBytes : usize , pBytesRead : * mut usize) -> ma_result ; } extern "C" { pub fn ma_vfs_write (pVFS : * mut ma_vfs , file : ma_vfs_file , pSrc : * const libc :: c_void , sizeInBytes : usize , pBytesWritten : * mut usize) -> ma_result ; } extern "C" { pub fn ma_vfs_seek (pVFS : * mut ma_vfs , file : ma_vfs_file , offset : ma_int64 , origin : ma_seek_origin) -> ma_result ; } extern "C" { pub fn ma_vfs_tell (pVFS : * mut ma_vfs , file : ma_vfs_file , pCursor : * mut ma_int64) -> ma_result ; } extern "C" { pub fn ma_vfs_info (pVFS : * mut ma_vfs , file : ma_vfs_file , pInfo : * mut ma_file_info) -> ma_result ; } extern "C" { pub fn ma_vfs_open_and_read_file (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , ppData : * mut * mut libc :: c_void , pSize : * mut usize , pAllocationCallbacks : * const ma_allocation_callbacks) -> ma_result ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_default_vfs { pub cb : ma_vfs_callbacks , pub allocationCallbacks : ma_allocation_callbacks , } extern "C" { pub fn ma_default_vfs_init (pVFS : * mut ma_default_vfs , pAllocationCallbacks : * const ma_allocation_callbacks) -> ma_result ; } pub const ma_resource_format_wav : ma_resource_format = 0 ; pub type ma_resource_format = libc :: c_uint ; pub type ma_decoder_read_proc = :: core :: option :: Option < unsafe extern "C" fn (pDecoder : * mut ma_decoder , pBufferOut : * mut libc :: c_void , bytesToRead : usize) -> usize > ; pub type ma_decoder_seek_proc = :: core :: option :: Option < unsafe extern "C" fn (pDecoder : * mut ma_decoder , byteOffset : libc :: c_int , origin : ma_seek_origin) -> ma_bool32 > ; pub type ma_decoder_read_pcm_frames_proc = :: core :: option :: Option < unsafe extern "C" fn (pDecoder : * mut ma_decoder , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64) -> ma_uint64 > ; pub type ma_decoder_seek_to_pcm_frame_proc = :: core :: option :: Option < unsafe extern "C" fn (pDecoder : * mut ma_decoder , frameIndex : ma_uint64) -> ma_result > ; pub type ma_decoder_uninit_proc = :: core :: option :: Option < unsafe extern "C" fn (pDecoder : * mut ma_decoder) -> ma_result > ; pub type ma_decoder_get_length_in_pcm_frames_proc = :: core :: option :: Option < unsafe extern "C" fn (pDecoder : * mut ma_decoder) -> ma_uint64 > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_decoder_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub channelMap : [ma_channel ; 32usize] , pub channelMixMode : ma_channel_mix_mode , pub ditherMode : ma_dither_mode , pub resampling : ma_decoder_config__bindgen_ty_1 , pub allocationCallbacks : ma_allocation_callbacks , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_decoder_config__bindgen_ty_1 { pub algorithm : ma_resample_algorithm , pub linear : ma_decoder_config__bindgen_ty_1__bindgen_ty_1 , pub speex : ma_decoder_config__bindgen_ty_1__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_decoder_config__bindgen_ty_1__bindgen_ty_1 { pub lpfOrder : ma_uint32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_decoder_config__bindgen_ty_1__bindgen_ty_2 { pub quality : libc :: c_int , } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_decoder { pub ds : ma_data_source_callbacks , pub onRead : ma_decoder_read_proc , pub onSeek : ma_decoder_seek_proc , pub pUserData : * mut libc :: c_void , pub readPointerInBytes : ma_uint64 , pub readPointerInPCMFrames : ma_uint64 , pub internalFormat : ma_format , pub internalChannels : ma_uint32 , pub internalSampleRate : ma_uint32 , pub internalChannelMap : [ma_channel ; 32usize] , pub outputFormat : ma_format , pub outputChannels : ma_uint32 , pub outputSampleRate : ma_uint32 , pub outputChannelMap : [ma_channel ; 32usize] , pub converter : ma_data_converter , pub allocationCallbacks : ma_allocation_callbacks , pub onReadPCMFrames : ma_decoder_read_pcm_frames_proc , pub onSeekToPCMFrame : ma_decoder_seek_to_pcm_frame_proc , pub onUninit : ma_decoder_uninit_proc , pub onGetLengthInPCMFrames : ma_decoder_get_length_in_pcm_frames_proc , pub pInternalDecoder : * mut libc :: c_void , pub backend : ma_decoder__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union ma_decoder__bindgen_ty_1 { pub vfs : ma_decoder__bindgen_ty_1__bindgen_ty_1 , pub memory : ma_decoder__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [u64 ; 3usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_decoder__bindgen_ty_1__bindgen_ty_1 { pub pVFS : * mut ma_vfs , pub file : ma_vfs_file , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_decoder__bindgen_ty_1__bindgen_ty_2 { pub pData : * const ma_uint8 , pub dataSize : usize , pub currentReadPos : usize , } impl :: core :: fmt :: Debug for ma_decoder__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_decoder__bindgen_ty_1 {{ union }}") } } impl :: core :: fmt :: Debug for ma_decoder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_decoder {{ ds: {:?}, onRead: {:?}, onSeek: {:?}, pUserData: {:?}, readPointerInBytes: {:?}, readPointerInPCMFrames: {:?}, internalFormat: {:?}, internalChannels: {:?}, internalSampleRate: {:?}, internalChannelMap: [...], outputFormat: {:?}, outputChannels: {:?}, outputSampleRate: {:?}, outputChannelMap: [...], converter: {:?}, allocationCallbacks: {:?}, onReadPCMFrames: {:?}, onSeekToPCMFrame: {:?}, onUninit: {:?}, onGetLengthInPCMFrames: {:?}, pInternalDecoder: {:?}, backend: {:?} }}" , self . ds , self . onRead , self . onSeek , self . pUserData , self . readPointerInBytes , self . readPointerInPCMFrames , self . internalFormat , self . internalChannels , self . internalSampleRate , self . outputFormat , self . outputChannels , self . outputSampleRate , self . converter , self . allocationCallbacks , self . onReadPCMFrames , self . onSeekToPCMFrame , self . onUninit , self . onGetLengthInPCMFrames , self . pInternalDecoder , self . backend) } } extern "C" { pub fn ma_decoder_config_init (outputFormat : ma_format , outputChannels : ma_uint32 , outputSampleRate : ma_uint32) -> ma_decoder_config ; } extern "C" { pub fn ma_decoder_init (onRead : ma_decoder_read_proc , onSeek : ma_decoder_seek_proc , pUserData : * mut libc :: c_void , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_wav (onRead : ma_decoder_read_proc , onSeek : ma_decoder_seek_proc , pUserData : * mut libc :: c_void , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_flac (onRead : ma_decoder_read_proc , onSeek : ma_decoder_seek_proc , pUserData : * mut libc :: c_void , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_mp3 (onRead : ma_decoder_read_proc , onSeek : ma_decoder_seek_proc , pUserData : * mut libc :: c_void , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vorbis (onRead : ma_decoder_read_proc , onSeek : ma_decoder_seek_proc , pUserData : * mut libc :: c_void , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_raw (onRead : ma_decoder_read_proc , onSeek : ma_decoder_seek_proc , pUserData : * mut libc :: c_void , pConfigIn : * const ma_decoder_config , pConfigOut : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_memory (pData : * const libc :: c_void , dataSize : usize , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_memory_wav (pData : * const libc :: c_void , dataSize : usize , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_memory_flac (pData : * const libc :: c_void , dataSize : usize , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_memory_mp3 (pData : * const libc :: c_void , dataSize : usize , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_memory_vorbis (pData : * const libc :: c_void , dataSize : usize , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_memory_raw (pData : * const libc :: c_void , dataSize : usize , pConfigIn : * const ma_decoder_config , pConfigOut : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_wav (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_flac (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_mp3 (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_vorbis (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_w (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_wav_w (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_flac_w (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_mp3_w (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_vfs_vorbis_w (pVFS : * mut ma_vfs , pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file (pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_wav (pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_flac (pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_mp3 (pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_vorbis (pFilePath : * const libc :: c_char , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_w (pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_wav_w (pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_flac_w (pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_mp3_w (pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_init_file_vorbis_w (pFilePath : * const wchar_t , pConfig : * const ma_decoder_config , pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_uninit (pDecoder : * mut ma_decoder) -> ma_result ; } extern "C" { pub fn ma_decoder_get_cursor_in_pcm_frames (pDecoder : * mut ma_decoder , pCursor : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_decoder_get_length_in_pcm_frames (pDecoder : * mut ma_decoder) -> ma_uint64 ; } extern "C" { pub fn ma_decoder_read_pcm_frames (pDecoder : * mut ma_decoder , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_decoder_seek_to_pcm_frame (pDecoder : * mut ma_decoder , frameIndex : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_decoder_get_available_frames (pDecoder : * mut ma_decoder , pAvailableFrames : * mut ma_uint64) -> ma_result ; } extern "C" { pub fn ma_decode_from_vfs (pVFS : * mut ma_vfs , pFilePath : * const libc :: c_char , pConfig : * mut ma_decoder_config , pFrameCountOut : * mut ma_uint64 , ppPCMFramesOut : * mut * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_decode_file (pFilePath : * const libc :: c_char , pConfig : * mut ma_decoder_config , pFrameCountOut : * mut ma_uint64 , ppPCMFramesOut : * mut * mut libc :: c_void) -> ma_result ; } extern "C" { pub fn ma_decode_memory (pData : * const libc :: c_void , dataSize : usize , pConfig : * mut ma_decoder_config , pFrameCountOut : * mut ma_uint64 , ppPCMFramesOut : * mut * mut libc :: c_void) -> ma_result ; } pub type ma_encoder_write_proc = :: core :: option :: Option < unsafe extern "C" fn (pEncoder : * mut ma_encoder , pBufferIn : * const libc :: c_void , bytesToWrite : usize) -> usize > ; pub type ma_encoder_seek_proc = :: core :: option :: Option < unsafe extern "C" fn (pEncoder : * mut ma_encoder , byteOffset : libc :: c_int , origin : ma_seek_origin) -> ma_bool32 > ; pub type ma_encoder_init_proc = :: core :: option :: Option < unsafe extern "C" fn (pEncoder : * mut ma_encoder) -> ma_result > ; pub type ma_encoder_uninit_proc = :: core :: option :: Option < unsafe extern "C" fn (pEncoder : * mut ma_encoder) > ; pub type ma_encoder_write_pcm_frames_proc = :: core :: option :: Option < unsafe extern "C" fn (pEncoder : * mut ma_encoder , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_uint64 > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_encoder_config { pub resourceFormat : ma_resource_format , pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub allocationCallbacks : ma_allocation_callbacks , } extern "C" { pub fn ma_encoder_config_init (resourceFormat : ma_resource_format , format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32) -> ma_encoder_config ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_encoder { pub config : ma_encoder_config , pub onWrite : ma_encoder_write_proc , pub onSeek : ma_encoder_seek_proc , pub onInit : ma_encoder_init_proc , pub onUninit : ma_encoder_uninit_proc , pub onWritePCMFrames : ma_encoder_write_pcm_frames_proc , pub pUserData : * mut libc :: c_void , pub pInternalEncoder : * mut libc :: c_void , pub pFile : * mut libc :: c_void , } extern "C" { pub fn ma_encoder_init (onWrite : ma_encoder_write_proc , onSeek : ma_encoder_seek_proc , pUserData : * mut libc :: c_void , pConfig : * const ma_encoder_config , pEncoder : * mut ma_encoder) -> ma_result ; } extern "C" { pub fn ma_encoder_init_file (pFilePath : * const libc :: c_char , pConfig : * const ma_encoder_config , pEncoder : * mut ma_encoder) -> ma_result ; } extern "C" { pub fn ma_encoder_init_file_w (pFilePath : * const wchar_t , pConfig : * const ma_encoder_config , pEncoder : * mut ma_encoder) -> ma_result ; } extern "C" { pub fn ma_encoder_uninit (pEncoder : * mut ma_encoder) ; } extern "C" { pub fn ma_encoder_write_pcm_frames (pEncoder : * mut ma_encoder , pFramesIn : * const libc :: c_void , frameCount : ma_uint64) -> ma_uint64 ; } pub const ma_waveform_type_sine : ma_waveform_type = 0 ; pub const ma_waveform_type_square : ma_waveform_type = 1 ; pub const ma_waveform_type_triangle : ma_waveform_type = 2 ; pub const ma_waveform_type_sawtooth : ma_waveform_type = 3 ; pub type ma_waveform_type = libc :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_waveform_config { pub format : ma_format , pub channels : ma_uint32 , pub sampleRate : ma_uint32 , pub type_ : ma_waveform_type , pub amplitude : f64 , pub frequency : f64 , } extern "C" { pub fn ma_waveform_config_init (format : ma_format , channels : ma_uint32 , sampleRate : ma_uint32 , type_ : ma_waveform_type , amplitude : f64 , frequency : f64) -> ma_waveform_config ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_waveform { pub ds : ma_data_source_callbacks , pub config : ma_waveform_config , pub advance : f64 , pub time : f64 , } extern "C" { pub fn ma_waveform_init (pConfig : * const ma_waveform_config , pWaveform : * mut ma_waveform) -> ma_result ; } extern "C" { pub fn ma_waveform_read_pcm_frames (pWaveform : * mut ma_waveform , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64) -> ma_uint64 ; } extern "C" { pub fn ma_waveform_seek_to_pcm_frame (pWaveform : * mut ma_waveform , frameIndex : ma_uint64) -> ma_result ; } extern "C" { pub fn ma_waveform_set_amplitude (pWaveform : * mut ma_waveform , amplitude : f64) -> ma_result ; } extern "C" { pub fn ma_waveform_set_frequency (pWaveform : * mut ma_waveform , frequency : f64) -> ma_result ; } extern "C" { pub fn ma_waveform_set_sample_rate (pWaveform : * mut ma_waveform , sampleRate : ma_uint32) -> ma_result ; } pub const ma_noise_type_white : ma_noise_type = 0 ; pub const ma_noise_type_pink : ma_noise_type = 1 ; pub const ma_noise_type_brownian : ma_noise_type = 2 ; pub type ma_noise_type = libc :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_noise_config { pub format : ma_format , pub channels : ma_uint32 , pub type_ : ma_noise_type , pub seed : ma_int32 , pub amplitude : f64 , pub duplicateChannels : ma_bool32 , } extern "C" { pub fn ma_noise_config_init (format : ma_format , channels : ma_uint32 , type_ : ma_noise_type , seed : ma_int32 , amplitude : f64) -> ma_noise_config ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ma_noise { pub ds : ma_data_source_callbacks , pub config : ma_noise_config , pub lcg : ma_lcg , pub state : ma_noise__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union ma_noise__bindgen_ty_1 { pub pink : ma_noise__bindgen_ty_1__bindgen_ty_1 , pub brownian : ma_noise__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [u64 ; 560usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_noise__bindgen_ty_1__bindgen_ty_1 { pub bin : [[f64 ; 16usize] ; 32usize] , pub accumulation : [f64 ; 32usize] , pub counter : [ma_uint32 ; 32usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ma_noise__bindgen_ty_1__bindgen_ty_2 { pub accumulation : [f64 ; 32usize] , } impl :: core :: fmt :: Debug for ma_noise__bindgen_ty_1 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_noise__bindgen_ty_1 {{ union }}") } } impl :: core :: fmt :: Debug for ma_noise { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { write ! (f , "ma_noise {{ ds: {:?}, config: {:?}, lcg: {:?}, state: {:?} }}" , self . ds , self . config , self . lcg , self . state) } } extern "C" { pub fn ma_noise_init (pConfig : * const ma_noise_config , pNoise : * mut ma_noise) -> ma_result ; } extern "C" { pub fn ma_noise_read_pcm_frames (pNoise : * mut ma_noise , pFramesOut : * mut libc :: c_void , frameCount : ma_uint64) -> ma_uint64 ; }